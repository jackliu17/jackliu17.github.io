<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cowboy Tech</title>
  <subtitle>The best preparation for tomorrow is doing your best today</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jackliu17.github.io/"/>
  <updated>2016-05-12T01:54:02.000Z</updated>
  <id>http://jackliu17.github.io/</id>
  
  <author>
    <name>Jack Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS数据存储</title>
    <link href="http://jackliu17.github.io/2016/05/12/iOS%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://jackliu17.github.io/2016/05/12/iOS数据存储/</id>
    <published>2016-05-12T01:52:26.000Z</published>
    <updated>2016-05-12T01:54:02.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;存储的方法&quot;&gt;&lt;a href=&quot;#存储的方法&quot; class=&quot;headerlink&quot; title=&quot;存储的方法&quot;&gt;&lt;/a&gt;存储的方法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;plist 需要知道文件名 只适合NSArray，NSString等基本数据类型&lt;/li&gt;
&lt;li&gt;偏好设置 不需要知道文件名，小型数据 NSUserDefaults，是以字典的方式存储&lt;/li&gt;
&lt;li&gt;对象归档  NSKeyedArchiver 必须实现NSCoding协议方法&lt;/li&gt;
&lt;li&gt;core Data 大型数据&lt;/li&gt;
&lt;li&gt;sqlite3&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;存储的方法&quot;&gt;&lt;a href=&quot;#存储的方法&quot; class=&quot;headerlink&quot; title=&quot;存储的方法&quot;&gt;&lt;/a&gt;存储的方法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;plist 需要知道文件名 只适合NSArray，NSString等基本数据类型&lt;/li&gt;
&lt;li&gt;偏好
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_dataStorage" scheme="http://jackliu17.github.io/tags/iOS-dataStorage/"/>
    
  </entry>
  
  <entry>
    <title>CAGradientLayer的使用</title>
    <link href="http://jackliu17.github.io/2016/05/09/CAGradientLayer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://jackliu17.github.io/2016/05/09/CAGradientLayer的使用/</id>
    <published>2016-05-09T02:18:17.000Z</published>
    <updated>2016-05-09T06:09:32.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;CAGradientLayer简介&quot;&gt;&lt;a href=&quot;#CAGradientLayer简介&quot; class=&quot;headerlink&quot; title=&quot;CAGradientLayer简介&quot;&gt;&lt;/a&gt;CAGradientLayer简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CAGradientLayer是用于处理渐变色的层结构&lt;/li&gt;
&lt;li&gt;CAGradientLayer的渐变色可以做隐式动画&lt;/li&gt;
&lt;li&gt;大部分情况下，CAGradientLayer都是与CAShapeLayer配合使用的&lt;/li&gt;
&lt;li&gt;CAGradientLayer可以用作png遮罩效果&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;多彩圆环&lt;/th&gt;
&lt;th&gt;多彩进度条&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerExample1.gif&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerExample2.gif&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动态多彩遮罩&lt;/th&gt;
&lt;th&gt;动态图像遮罩&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerExample3.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerExample4.png&quot; alt=&quot;&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;CAGradientLayer坐标系统&quot;&gt;&lt;a href=&quot;#CAGradientLayer坐标系统&quot; class=&quot;headerlink&quot; title=&quot;CAGradientLayer坐标系统&quot;&gt;&lt;/a&gt;CAGradientLayer坐标系统&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerCoordinate.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CAGradientLayer的坐标系统是从坐标（0，0）到（1，1）绘制的矩形&lt;/li&gt;
&lt;li&gt;CAGradientLayer的frame值的size不为正方形的话，坐标系统会被拉伸&lt;/li&gt;
&lt;li&gt;CAGradientLayer的startPoint与endPoint会直接影响颜色的绘制方向&lt;/li&gt;
&lt;li&gt;CAGradientLayer的颜色分割点是以0到1的比例来计算的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerProj1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()
@property (strong, nonatomic) CAGradientLayer *gradientLayer;

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
// 创建并初始化
self.gradientLayer             = [CAGradientLayer layer];
self.gradientLayer.frame       = CGRectMake(0, 0, 200, 200);
self.gradientLayer.position    = self.view.center;
self.gradientLayer.borderWidth = 1.f;
[self.view.layer addSublayer:self.gradientLayer];

// 设置颜色
self.gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,
                              (__bridge id)[UIColor greenColor].CGColor,
                              (__bridge id)[UIColor blueColor].CGColor];

// 设置颜色渐变方向
self.gradientLayer.startPoint = CGPointMake(0, 0);
self.gradientLayer.endPoint   = CGPointMake(1, 0);

// 设置颜色分割点
self.gradientLayer.locations  = @[@(0.25), @(0.5), @(0.75)];


// 延时3秒钟执行
[self performSelector:@selector(gradientLayerLocationAnimation)
           withObject:nil
           afterDelay:3.f];

       }

- (void)gradientLayerLocationAnimation {
// 颜色分割点效果
self.gradientLayer.locations = @[@(0.01), @(0.5), @(0.99)];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;色差动画实现&quot;&gt;&lt;a href=&quot;#色差动画实现&quot; class=&quot;headerlink&quot; title=&quot;色差动画实现&quot;&gt;&lt;/a&gt;色差动画实现&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerColor.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定渐变色渐变方向&lt;/li&gt;
&lt;li&gt;设定两种颜色，其中一种是透明色，另外一种是自定义颜色&lt;/li&gt;
&lt;li&gt;设定好location颜色分割点值&lt;/li&gt;
&lt;li&gt;CAGradientLayer的颜色分割点是以0到1的比例来计算的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerProj2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()

@property (nonatomic, strong) CAGradientLayer *gradientLayer; // 渐变层
@property (nonatomic, strong) NSTimer         *timer;         // 定时器

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];

self.view.backgroundColor = [UIColor blackColor];

// 创建背景图片
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&amp;quot;bg&amp;quot;]];
imageView.center       = self.view.center;
[self.view addSubview:imageView];

// 初始化渐变层
self.gradientLayer       = [CAGradientLayer layer];
self.gradientLayer.frame = imageView.bounds;
[imageView.layer addSublayer:self.gradientLayer];

// 设定颜色渐变方向
self.gradientLayer.startPoint = CGPointMake(0, 0);
self.gradientLayer.endPoint   = CGPointMake(0, 1);

// 设定颜色组
self.gradientLayer.colors = @[(__bridge id)[UIColor clearColor].CGColor,
                              (__bridge id)[UIColor redColor].CGColor];

// 设定颜色分割点
self.gradientLayer.locations = @[@(0.5f), @(1.f)];

// 初始化定时器
self.timer = [NSTimer scheduledTimerWithTimeInterval:2.f
                                              target:self
                                            selector:@selector(timerEvent)
                                            userInfo:nil
                                             repeats:YES];
                                         }

- (void)timerEvent {
// 设定颜色组动画
self.gradientLayer.colors = @[(__bridge id)[UIColor clearColor].CGColor,
                              (__bridge id)[UIColor colorWithRed:arc4random() % 255 / 255.f
                                                           green:arc4random() % 255 / 255.f
                                                            blue:arc4random() % 255 / 255.f
                                                           alpha:1].CGColor];

// 设定颜色分割点动画
self.gradientLayer.locations = @[@(arc4random() % 10 / 10.f), @(1.f)];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用CAGradientLayer封装带色差动画的View&quot;&gt;&lt;a href=&quot;#用CAGradientLayer封装带色差动画的View&quot; class=&quot;headerlink&quot; title=&quot;用CAGradientLayer封装带色差动画的View&quot;&gt;&lt;/a&gt;用CAGradientLayer封装带色差动画的View&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;确定几个属性值&lt;/li&gt;
&lt;li&gt;确定可以做动画的参数&lt;/li&gt;
&lt;li&gt;重写setter方法做动画&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAGradientLayerProj3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;p&gt;ColorUIImageView.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;

typedef enum : NSUInteger {
UP,    // 从上往下
DOWN,  // 从下往上
RIGHT, // 从右往左
LEFT,  // 从左往右
} EColorDirection;

@interface ColorUIImageView : UIImageView

/**
 *  确定方向（可以做动画）
 */
@property (nonatomic, assign) EColorDirection  direction;

/**
 *  颜色（可以做动画）
 */
 @property (nonatomic, strong) UIColor  *color;

 /**
 *  百分比（可以做动画）
 */
@property (nonatomic, assign) CGFloat   percent;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ColorUIImageView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ColorUIImageView.h&amp;quot;

@interface ColorUIImageView ()

@property (nonatomic, strong) CAGradientLayer *gradientLayer;

@end

@implementation ColorUIImageView

- (instancetype)initWithFrame:(CGRect)frame
{
self = [super initWithFrame:frame];
if (self) {
    // 初始化CAGradientLayer
    self.gradientLayer           = [CAGradientLayer layer];
    self.gradientLayer.frame     = self.bounds;

    self.gradientLayer.colors    = @[(__bridge id)[UIColor clearColor].CGColor,
                                     (__bridge id)[UIColor redColor].CGColor];
    self.gradientLayer.locations = @[@(1), @(1)];

    [self.layer addSublayer:self.gradientLayer];
}
return self;
}

#pragma mark - 重写setter，getter方法
@synthesize color = _color;
- (void)setColor:(UIColor *)color {
_color = color;
self.gradientLayer.colors = @[(__bridge id)[UIColor clearColor].CGColor,
                              (__bridge id)color.CGColor];
                          }
- (UIColor *)color {
return _color;
}

@synthesize percent = _percent;
- (void)setPercent:(CGFloat)percent {
_percent = percent;
self.gradientLayer.locations = @[@(percent), @(1)];
}
- (CGFloat)percent {
return _percent;
}

@synthesize direction = _direction;
- (void)setDirection:(EColorDirection)direction {
_direction = direction;
if (direction == UP) {
    self.gradientLayer.startPoint = CGPointMake(0, 0);
    self.gradientLayer.endPoint   = CGPointMake(0, 1);
} else if (direction == DOWN) {
    self.gradientLayer.startPoint = CGPointMake(0, 1);
    self.gradientLayer.endPoint   = CGPointMake(0, 0);
} else if (direction == RIGHT) {
    self.gradientLayer.startPoint = CGPointMake(1, 0);
    self.gradientLayer.endPoint   = CGPointMake(0, 0);
} else if (direction == LEFT) {
    self.gradientLayer.startPoint = CGPointMake(0, 0);
    self.gradientLayer.endPoint   = CGPointMake(1, 0);
} else {
    self.gradientLayer.startPoint = CGPointMake(0, 0);
    self.gradientLayer.endPoint   = CGPointMake(0, 1);
}
}
- (EColorDirection)direction {
return _direction;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ViewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;ColorUIImageView.h&amp;quot;
@interface ViewController ()
@property (nonatomic, strong) ColorUIImageView *colorView;

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.


self.colorView        = [[ColorUIImageView alloc] initWithFrame:CGRectMake(0, 0, 198, 253)];
self.colorView.center = self.view.center;
self.colorView.image  = [UIImage imageNamed:@&amp;quot;bg&amp;quot;];
[self.view addSubview:self.colorView];

[self performSelector:@selector(event)
           withObject:nil
           afterDelay:2.f];
       }

- (void)event {
self.colorView.direction = DOWN;
self.colorView.color     = [UIColor cyanColor];
self.colorView.percent   = 0.5;
}
@end
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CAGradientLayer简介&quot;&gt;&lt;a href=&quot;#CAGradientLayer简介&quot; class=&quot;headerlink&quot; title=&quot;CAGradientLayer简介&quot;&gt;&lt;/a&gt;CAGradientLayer简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CAGr
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_CALayer" scheme="http://jackliu17.github.io/tags/iOS-CALayer/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer的使用</title>
    <link href="http://jackliu17.github.io/2016/05/08/CAShapeLayer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://jackliu17.github.io/2016/05/08/CAShapeLayer的使用/</id>
    <published>2016-05-08T09:58:30.000Z</published>
    <updated>2016-05-08T10:06:53.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;CAShapeLayer简介&quot;&gt;&lt;a href=&quot;#CAShapeLayer简介&quot; class=&quot;headerlink&quot; title=&quot;CAShapeLayer简介&quot;&gt;&lt;/a&gt;CAShapeLayer简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CAShapeLayer继承至CALayer，可以使用CALayer的所有属性值&lt;/li&gt;
&lt;li&gt;CAShapeLayer需要与贝塞尔曲线配合使用才有意义&lt;/li&gt;
&lt;li&gt;使用CAShapeLayer与贝塞尔曲线可以实现不在view的drawRect方法中画出一些想要的图形&lt;/li&gt;
&lt;li&gt;CAShapeLayer属于CoreAnimation框架，其动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言，其效率极高，能大大优化内存使用情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAShaperLayer01.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()
@property (nonatomic, strong) NSTimer      *timer;
@property (nonatomic, strong) CAShapeLayer *shapeLayer;

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];

// 创建shapeLayer
_shapeLayer = [CAShapeLayer layer];
_shapeLayer.frame         = (CGRect){CGPointMake(0, 0), CGSizeMake(200, 200)};
_shapeLayer.position      = self.view.center;
_shapeLayer.path          = [self getStar1BezierPath].CGPath;
_shapeLayer.fillColor     = [UIColor clearColor].CGColor;
_shapeLayer.strokeColor   = [UIColor redColor].CGColor;
_shapeLayer.lineWidth     = 2.f;
[self.view.layer addSublayer:_shapeLayer];

// 创建定时器
_timer = [NSTimer scheduledTimerWithTimeInterval:1.f
                                          target:self
                                        selector:@selector(pathAnimation)
                                        userInfo:nil
                                         repeats:YES];
}

/**
 *  执行path的动画
 */
- (void)pathAnimation {
static int i = 0;
if (i++ % 2 == 0) {
    CABasicAnimation *circleAnim = [CABasicAnimation animationWithKeyPath:@&amp;quot;path&amp;quot;];
    circleAnim.removedOnCompletion = NO;
    circleAnim.duration            = 1;
    circleAnim.fromValue           = (__bridge id)[self getStar1BezierPath].CGPath;
    circleAnim.toValue             = (__bridge id)[self getStar2BezierPath].CGPath;
    _shapeLayer.path               = [self getStar2BezierPath].CGPath;
    [_shapeLayer addAnimation:circleAnim forKey:@&amp;quot;animateCirclePath&amp;quot;];
} else {
    CABasicAnimation *circleAnim = [CABasicAnimation animationWithKeyPath:@&amp;quot;path&amp;quot;];
    circleAnim.removedOnCompletion = NO;
    circleAnim.duration            = 1;
    circleAnim.fromValue           = (__bridge id)[self getStar2BezierPath].CGPath;
    circleAnim.toValue             = (__bridge id)[self getStar1BezierPath].CGPath;
    _shapeLayer.path               = [self getStar1BezierPath].CGPath;
    [_shapeLayer addAnimation:circleAnim forKey:@&amp;quot;animateCirclePath&amp;quot;];
}
}

/**
 *  贝塞尔曲线1
 *
 *  @return 贝塞尔曲线
 */
-(UIBezierPath *)getStar1BezierPath {
//// Star Drawing
UIBezierPath* starPath = [UIBezierPath bezierPath];
[starPath moveToPoint: CGPointMake(22.5, 2.5)];
[starPath addLineToPoint: CGPointMake(28.32, 14.49)];
[starPath addLineToPoint: CGPointMake(41.52, 16.32)];
[starPath addLineToPoint: CGPointMake(31.92, 25.56)];
[starPath addLineToPoint: CGPointMake(34.26, 38.68)];
[starPath addLineToPoint: CGPointMake(22.5, 32.4)];
[starPath addLineToPoint: CGPointMake(10.74, 38.68)];
[starPath addLineToPoint: CGPointMake(13.08, 25.56)];
[starPath addLineToPoint: CGPointMake(3.48, 16.32)];
[starPath addLineToPoint: CGPointMake(16.68, 14.49)];
[starPath closePath];

return starPath;
}

/**
 *  贝塞尔曲线2
 *
 *  @return 贝塞尔曲线
 */
-(UIBezierPath *)getStar2BezierPath {
//// Star Drawing
UIBezierPath* starPath = [UIBezierPath bezierPath];
[starPath moveToPoint: CGPointMake(22.5, 2.5)];
[starPath addLineToPoint: CGPointMake(32.15, 9.21)];
[starPath addLineToPoint: CGPointMake(41.52, 16.32)];
[starPath addLineToPoint: CGPointMake(38.12, 27.57)];
[starPath addLineToPoint: CGPointMake(34.26, 38.68)];
[starPath addLineToPoint: CGPointMake(22.5, 38.92)];
[starPath addLineToPoint: CGPointMake(10.74, 38.68)];
[starPath addLineToPoint: CGPointMake(6.88, 27.57)];
[starPath addLineToPoint: CGPointMake(3.48, 16.32)];
[starPath addLineToPoint: CGPointMake(12.85, 9.21)];
[starPath closePath];

return starPath;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;贝塞尔曲线与CAShapeLayer的关系&quot;&gt;&lt;a href=&quot;#贝塞尔曲线与CAShapeLayer的关系&quot; class=&quot;headerlink&quot; title=&quot;贝塞尔曲线与CAShapeLayer的关系&quot;&gt;&lt;/a&gt;贝塞尔曲线与CAShapeLayer的关系&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CAShapeLayer中有Shape这个单词，顾名思义，它需要一个形状才能生效&lt;/li&gt;
&lt;li&gt;贝塞尔曲线可以创建基于矢量的路径&lt;/li&gt;
&lt;li&gt;贝塞尔曲线给CAShapeLayer提供路径，CAShapeLayer在提供的路径中进行渲染，路径会闭环，所以路径绘制出了Shape&lt;/li&gt;
&lt;li&gt;用于CAShapeLayer的贝塞尔曲线作为path，其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAShaperLayer02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
// 创建椭圆形贝塞尔曲线
UIBezierPath *oval = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 200, 100)];

// 创建矩形贝塞尔曲线
UIBezierPath *rect = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 200, 100)];

// 创建圆形贝塞尔曲线
UIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)];

// 创建CAShapeLayer
CAShapeLayer *shape = [CAShapeLayer layer];
shape.frame         = CGRectMake(0, 0, 200, 50);
shape.position      = self.view.center;

// 显示CAShapeLayer的边界
shape.borderWidth   = 1.f;

// 禁止内容显示超出CAShapeLayer的frame值
shape.masksToBounds = YES;

// 修改贝塞尔曲线的填充颜色
shape.fillColor     = [UIColor redColor].CGColor;

// 建立贝塞尔曲线与CAShapeLayer之间的关联
shape.path = circle.CGPath;

// 添加并显示
[self.view.layer addSublayer:shape];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;StrokeStart与StrokeEnd动画&quot;&gt;&lt;a href=&quot;#StrokeStart与StrokeEnd动画&quot; class=&quot;headerlink&quot; title=&quot;StrokeStart与StrokeEnd动画&quot;&gt;&lt;/a&gt;StrokeStart与StrokeEnd动画&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;进度条效果 - 利用GPU实现，不占内存&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将ShapeLayer的fillColor设置成透明背景&lt;/li&gt;
&lt;li&gt;设置线条的宽度（lineWidth）的值&lt;/li&gt;
&lt;li&gt;设置线条的颜色&lt;/li&gt;
&lt;li&gt;将strokeStart值设定成0，然后让strokeEnd的值变化触发隐式动画&lt;/li&gt;
&lt;li&gt;strokeStart的值一定小于strokeEnd&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAShaperLayer03.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()
@property (nonatomic, strong) NSTimer      *timer;      // 定时器
@property (nonatomic, strong) CAShapeLayer *shapeLayer; // 形状layer

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 设置背景色
self.view.backgroundColor = [UIColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1];

// 创建椭圆形贝塞尔曲线
UIBezierPath *oval        = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)];

// 创建CAShapeLayer
_shapeLayer               = [CAShapeLayer layer];
_shapeLayer.frame         = CGRectMake(0, 0, 100, 100);
_shapeLayer.position      = self.view.center;

// 修改CAShapeLayer的线条相关值
_shapeLayer.fillColor     = [UIColor clearColor].CGColor;
_shapeLayer.strokeColor   = [UIColor redColor].CGColor;
_shapeLayer.lineWidth     = 2.f;
_shapeLayer.strokeStart   = 0.f;
_shapeLayer.strokeEnd     = 0.f;

// 建立贝塞尔曲线与CAShapeLayer之间的关联
_shapeLayer.path          = oval.CGPath;

// 添加并显示
[self.view.layer addSublayer:_shapeLayer];

// 创建定时器
_timer = [NSTimer scheduledTimerWithTimeInterval:1.f
                                          target:self
                                        selector:@selector(animationEventTypeTwo)
                                        userInfo:nil
                                         repeats:YES];
                                     }

/**
 *  动画效果1
*/
- (void)animationEventTypeOne {
// 执行隐式动画
_shapeLayer.strokeEnd = arc4random() % 100 / 100.f;
}

/**
 *  动画效果2
 */
 - (void)animationEventTypeTwo {
CGFloat valueOne = arc4random() % 100 / 100.f;
CGFloat valueTwo = arc4random() % 100 / 100.f;

// 执行隐式动画
_shapeLayer.strokeStart = valueOne &amp;lt; valueTwo ? valueOne : valueTwo;
_shapeLayer.strokeEnd   = valueOne &amp;gt; valueTwo ? valueOne : valueTwo;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用CAShapeLayer实现圆形进度条效果&quot;&gt;&lt;a href=&quot;#用CAShapeLayer实现圆形进度条效果&quot; class=&quot;headerlink&quot; title=&quot;用CAShapeLayer实现圆形进度条效果&quot;&gt;&lt;/a&gt;用CAShapeLayer实现圆形进度条效果&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;确定需要设定的参数&lt;/li&gt;
&lt;li&gt;实现细节&lt;/li&gt;
&lt;li&gt;进行测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAShaperLayer04.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-3&quot;&gt;&lt;a href=&quot;#代码-3&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;p&gt;viewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;CircleView.h&amp;quot;
@interface ViewController ()
{
CircleView *circle;
}
@end

@implementation ViewController
- (void)viewDidLoad {
[super viewDidLoad];

circle             = [[CircleView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
circle.center      = self.view.center;
circle.startValue  = 0.5;
circle.lineWidth   = 3.f;
circle.lineColor   = [UIColor grayColor];
[self.view addSubview:circle];

[self performSelector:@selector(delayAnimation)
           withObject:nil
           afterDelay:3.f];
       }

- (void)delayAnimation {
circle.value = 1.f;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;circleView.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface CircleView : UIView
@property (nonatomic, assign) CGFloat  startValue; // 起始值（0~1）
@property (nonatomic, assign) CGFloat  lineWidth;  // 线宽(&amp;gt;0)
@property (nonatomic, strong) UIColor *lineColor;  // 线条颜色
@property (nonatomic, assign) CGFloat  value;      // 变化的值

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;circleView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;CircleView.h&amp;quot;
@interface CircleView ()

@property (nonatomic, strong) CAShapeLayer *shapeLayer;

@end
@implementation CircleView

- (instancetype)initWithFrame:(CGRect)frame {
self = [super initWithFrame:frame];
if (self) {
    // 创建出CAShapeLayer
    _shapeLayer       = [CAShapeLayer layer];
    _shapeLayer.frame = self.bounds;

    // 创建出贝塞尔曲线
    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:self.bounds];

    // 贝塞尔曲线与CAShapeLayer产生关联
    _shapeLayer.path = path.CGPath;

    // 基本配置
    _shapeLayer.fillColor   = [UIColor clearColor].CGColor;
    _shapeLayer.lineWidth   = 1.f;
    _shapeLayer.strokeColor = [UIColor redColor].CGColor;
    _shapeLayer.strokeEnd   = 0.f;

    // 添加到当前view
    [self.layer addSublayer:_shapeLayer];
}
return self;
}

@synthesize startValue = _startValue;
- (void)setStartValue:(CGFloat)startValue {
_startValue           = startValue;
_shapeLayer.strokeEnd = startValue;
}
- (CGFloat)startValue {
return _startValue;
}

@synthesize lineWidth = _lineWidth;
- (void)setLineWidth:(CGFloat)lineWidth {
_lineWidth            = lineWidth;
_shapeLayer.lineWidth = lineWidth;
}
- (CGFloat)lineWidth {
return _lineWidth;
}

@synthesize lineColor = _lineColor;
- (void)setLineColor:(UIColor *)lineColor {
_lineColor              = lineColor;
_shapeLayer.strokeColor = lineColor.CGColor;
}
- (UIColor *)lineColor {
return _lineColor;
}

@synthesize value = _value;
- (void)setValue:(CGFloat)value {
_value                = value;
_shapeLayer.strokeEnd = value;
}
- (CGFloat)value {
return _value;
}


@end
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CAShapeLayer简介&quot;&gt;&lt;a href=&quot;#CAShapeLayer简介&quot; class=&quot;headerlink&quot; title=&quot;CAShapeLayer简介&quot;&gt;&lt;/a&gt;CAShapeLayer简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CAShapeLayer继承至C
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_CALayer" scheme="http://jackliu17.github.io/tags/iOS-CALayer/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
  </entry>
  
  <entry>
    <title>CALayer的使用</title>
    <link href="http://jackliu17.github.io/2016/05/08/CALayer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://jackliu17.github.io/2016/05/08/CALayer的使用/</id>
    <published>2016-05-08T07:07:09.000Z</published>
    <updated>2016-05-08T07:08:57.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;CALayer简介&quot;&gt;&lt;a href=&quot;#CALayer简介&quot; class=&quot;headerlink&quot; title=&quot;CALayer简介&quot;&gt;&lt;/a&gt;CALayer简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CALayer一般作为UIView的容器而使用&lt;/li&gt;
&lt;li&gt;CALayer是一个管理着图片载体（image-based content）的层结构, &lt;strong&gt;UIView中CALayer的值设定(如frame, backgroundColor)可以覆盖其UIView中的设定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;直接修改单独创建出的CALayer的属性可以触发隐式动画&lt;/li&gt;
&lt;li&gt;UIView中的CALayer动画必须显式触发才能生效&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;用CALayer定制下载进度条控件&quot;&gt;&lt;a href=&quot;#用CALayer定制下载进度条控件&quot; class=&quot;headerlink&quot; title=&quot;用CALayer定制下载进度条控件&quot;&gt;&lt;/a&gt;用CALayer定制下载进度条控件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;单独创建出CALayer&lt;/li&gt;
&lt;li&gt;直接修改CALayer的frame值执行隐式动画，实现进度条效果&lt;/li&gt;
&lt;li&gt;用定时器（NSTimer）模拟网络下载时提供的百分比数据&lt;/li&gt;
&lt;li&gt;将CALayer封装进UIView子类中定制进度条控件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CALayer_progressView.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;隐式动画进度条&quot;&gt;&lt;a href=&quot;#隐式动画进度条&quot; class=&quot;headerlink&quot; title=&quot;隐式动画进度条&quot;&gt;&lt;/a&gt;隐式动画进度条&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()

@property (nonatomic, strong) NSTimer *timer; // 定时器
@property (nonatomic, strong) CALayer *layer; // layer

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];

// 设置背景色
self.view.backgroundColor = [UIColor blackColor];

// CALayer
_layer                 = [CALayer layer];
_layer.frame           = CGRectMake(50, 50, 200, 2);
_layer.backgroundColor = [UIColor redColor].CGColor;
[self.view.layer addSublayer:_layer];

// 定时器
_timer = [NSTimer scheduledTimerWithTimeInterval:1.f
                                          target:self
                                        selector:@selector(timerEvent)
                                        userInfo:nil
                                         repeats:YES];
                                     }


- (void)timerEvent {
// 执行layer的隐式动画（取随机值模拟下载进度）
_layer.frame = CGRectMake(50, 50, arc4random()%200, 2);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;封装UIView实现进度条&quot;&gt;&lt;a href=&quot;#封装UIView实现进度条&quot; class=&quot;headerlink&quot; title=&quot;封装UIView实现进度条&quot;&gt;&lt;/a&gt;封装UIView实现进度条&lt;/h2&gt;&lt;p&gt;progressView.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface ProgressView : UIView

@property (nonatomic, assign) CGFloat  progress;   // 进度参数（取值范围为 %0 ~ %100）
@property (nonatomic, strong) UIColor *layerColor; // 修改layer的颜色

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;progressView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ProgressView.h&amp;quot;

@interface ProgressView ()

@property (nonatomic, strong) CALayer *progressLayer;
@property (nonatomic, assign) CGFloat  currentViewWidth;

@end

@implementation ProgressView

- (instancetype)initWithFrame:(CGRect)frame
{
self = [super initWithFrame:frame];
if (self) {
    self.progressLayer       = [CALayer layer];
    self.progressLayer.frame = CGRectMake(0, 0, 0, frame.size.height);
    self.progressLayer.backgroundColor = [UIColor redColor].CGColor;
    [self.layer addSublayer:self.progressLayer];

    // 存储当前view的宽度值
    self.currentViewWidth = frame.size.width;
}
return self;
}

#pragma mark - 重写setter，getter方法
@synthesize progress = _progress;

- (void)setProgress:(CGFloat)progress {
_progress = progress;

if (progress &amp;lt;= 0) {
    self.progressLayer.frame = CGRectMake(0, 0, 0, self.frame.size.height);
} else if (progress &amp;lt;= 1) {
    self.progressLayer.frame = CGRectMake(0, 0,
                                          progress * self.currentViewWidth,
                                          self.frame.size.height);
} else {
    self.progressLayer.frame = CGRectMake(0, 0, self.currentViewWidth,
                                          self.frame.size.height);
}
}

- (CGFloat)progress {
return _progress;
}

@synthesize layerColor = _layerColor;

- (void)setLayerColor:(UIColor *)layerColor {
_layerColor = layerColor;
self.progressLayer.backgroundColor = layerColor.CGColor;
}

- (UIColor *)layerColor {
return _layerColor;
}


@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;viewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;ProgressView.h&amp;quot;
@interface ViewController ()
@property (nonatomic, strong) ProgressView *progressView;
@property (nonatomic, strong) NSTimer      *timer;

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

self.view.backgroundColor = [UIColor blackColor];

self.progressView            = [[ProgressView alloc] initWithFrame:CGRectMake(20, 20, 290, 3)];
self.progressView.layerColor = [UIColor yellowColor];
[self.view addSubview:self.progressView];

// 创建定时器，每一秒执行一回
self.timer = [NSTimer scheduledTimerWithTimeInterval:1
                                              target:self
                                            selector:@selector(layerAnimation)
                                            userInfo:nil
                                             repeats:YES];
                                         }

- (void)layerAnimation {
// 随机获取 0% ~ 100% 给layer赋值
self.progressView.progress = arc4random() % 100 / 100.f;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用CALayer定制UIImageView淡入淡出切换图片效果&quot;&gt;&lt;a href=&quot;#用CALayer定制UIImageView淡入淡出切换图片效果&quot; class=&quot;headerlink&quot; title=&quot;用CALayer定制UIImageView淡入淡出切换图片效果&quot;&gt;&lt;/a&gt;用CALayer定制UIImageView淡入淡出切换图片效果&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CALayer01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作UIImageView的CALayer修改其bounds值进行显式动画&lt;/li&gt;
&lt;li&gt;修改UIImageView的CALayer中的contents属性实现切换图片的动画&lt;/li&gt;
&lt;li&gt;用CAAnimationGroup将bounds动画与contents动画组合起来&lt;/li&gt;
&lt;li&gt;将上述效果封装进UIView的子类中生成控件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CALayer03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

#define NO_EXECUTE  0  // 不执行
#define EXECUTE     1  // 执行


@interface ViewController ()
@property (nonatomic, strong) CALayer *imageLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 创建出独立的layer
self.imageLayer          = [CALayer layer];
self.imageLayer.frame    = CGRectMake(0, 0, 302, 707);
// 给layer的contents属性设置图片
self.imageLayer.contents = (__bridge id)([UIImage imageNamed:@&amp;quot;起始图片&amp;quot;].CGImage);
[self.view.layer addSublayer:self.imageLayer];


// 3s后执行layer动画
[self performSelector:@selector(layerAnimation)
           withObject:nil
           afterDelay:3.f];
       }

- (void)layerAnimation {

if (NO_EXECUTE) {
    // 执行隐式动画（你自己无法控制持续时间等等的参数）
    self.imageLayer.contents = (__bridge id)([UIImage imageNamed:@&amp;quot;结束图片&amp;quot;].CGImage);
}

if (NO_EXECUTE) {
    // 执行显式动画

    // 设定基本动画参数
    CABasicAnimation *contentsAnimation = [CABasicAnimation animationWithKeyPath:@&amp;quot;contents&amp;quot;];
    contentsAnimation.fromValue         =  self.imageLayer.contents;
    contentsAnimation.toValue           =  (__bridge id)([UIImage imageNamed:@&amp;quot;结束图片&amp;quot;].CGImage);
    contentsAnimation.duration          = 3.f;

    // 设定layer动画结束后的contents值
    self.imageLayer.contents         = (__bridge id)([UIImage imageNamed:@&amp;quot;结束图片&amp;quot;].CGImage);

    // 让layer开始执行动画
    [self.imageLayer addAnimation:contentsAnimation forKey:nil];
}

if (EXECUTE) {
    // 执行显式动画

    // 基于图片的动画
    CABasicAnimation *contentsAnimation = [CABasicAnimation animationWithKeyPath:@&amp;quot;contents&amp;quot;];
    contentsAnimation.fromValue         =  self.imageLayer.contents;
    contentsAnimation.toValue           =  (__bridge id)([UIImage imageNamed:@&amp;quot;结束图片&amp;quot;].CGImage);
    contentsAnimation.duration          = 0.5f;

    // 基于bounds的动画
    CABasicAnimation *boundsAnimation = [CABasicAnimation animationWithKeyPath:@&amp;quot;bounds&amp;quot;];
    boundsAnimation.fromValue         = [NSValue valueWithCGRect:self.imageLayer.bounds];
    boundsAnimation.toValue           = [NSValue valueWithCGRect:CGRectMake(0, 0, 302/2.f, 707/2.f)];
    boundsAnimation.duration          = 0.5f;

    // 将基于图片的动画与基于bounds的动画组合起来
    CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];
    groupAnimation.animations        = @[contentsAnimation, boundsAnimation];
    groupAnimation.duration          = 0.5f;

    // 设定layer动画结束后的contents值
    self.imageLayer.contents = (__bridge id)([UIImage imageNamed:@&amp;quot;结束图片&amp;quot;].CGImage);
    self.imageLayer.bounds   = CGRectMake(0, 0, 302/2.f, 707/2.f);

    // 让layer开始执行动画
    [self.imageLayer addAnimation:groupAnimation forKey:nil];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用CALayer实现复杂遮罩效果&quot;&gt;&lt;a href=&quot;#用CALayer实现复杂遮罩效果&quot; class=&quot;headerlink&quot; title=&quot;用CALayer实现复杂遮罩效果&quot;&gt;&lt;/a&gt;用CALayer实现复杂遮罩效果&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CALayer2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遮罩原理的分析&lt;/li&gt;
&lt;li&gt;用png图片作为CALayer中mask属性的遮罩Layer&lt;/li&gt;
&lt;li&gt;移动该CALayer的mask的frame值实现遮罩动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;CALayer实现遮罩淡化滤镜&quot;&gt;&lt;a href=&quot;#CALayer实现遮罩淡化滤镜&quot; class=&quot;headerlink&quot; title=&quot;CALayer实现遮罩淡化滤镜&quot;&gt;&lt;/a&gt;CALayer实现遮罩淡化滤镜&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()

@property (nonatomic, strong) CALayer *imageLayer;
@property (nonatomic, strong) CALayer *maskLayer;

@property (nonatomic, strong) UIImage *contentImage;
@property (nonatomic, strong) UIImage *maskImage;

@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

self.view.backgroundColor = [UIColor blackColor];

// 处理图片
self.contentImage = [UIImage imageNamed:@&amp;quot;原始图片&amp;quot;];
self.maskImage    = [UIImage imageNamed:@&amp;quot;maskLayerContents&amp;quot;];


// 生成maskLayer
self.maskLayer          = [CALayer layer];
self.maskLayer.frame    = CGRectMake(0, 0, 427/2.f, 427/2.f);
self.maskLayer.contents = (__bridge id)(self.maskImage.CGImage);


// 生成contentsLayer
self.imageLayer          = [CALayer layer];
self.imageLayer.frame    = CGRectMake(0, 0, 427/2.f, 427/2.f);
self.imageLayer.contents = (__bridge id)(self.contentImage.CGImage);


// 给contentsLayer设定mask值
self.imageLayer.mask     = self.maskLayer;


// 将contentsLayer添加到layer中
[self.view.layer addSublayer:self.imageLayer];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;CALayer实现遮罩平移&quot;&gt;&lt;a href=&quot;#CALayer实现遮罩平移&quot; class=&quot;headerlink&quot; title=&quot;CALayer实现遮罩平移&quot;&gt;&lt;/a&gt;CALayer实现遮罩平移&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;

@interface ViewController ()
@property (nonatomic, strong) CALayer *imageLayer;
@property (nonatomic, strong) CALayer *maskLayer;

@property (nonatomic, strong) UIImage *imageContents;
@property (nonatomic, strong) UIImage *maskContents;


@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

self.view.backgroundColor = [UIColor blackColor];

// 获取图片
self.imageContents = [UIImage imageNamed:@&amp;quot;原始图片&amp;quot;];
self.maskContents  = [UIImage imageNamed:@&amp;quot;maskLayerContents&amp;quot;];

// 创建出图片layer
self.imageLayer          = [CALayer layer];
self.imageLayer.frame    = CGRectMake(50, 50, 200, 200);
self.imageLayer.contents = (__bridge id)(self.imageContents.CGImage);
[self.view.layer addSublayer:self.imageLayer];

// 创建出遮罩layer
self.maskLayer          = [CALayer layer];
self.maskLayer.frame    = self.imageLayer.bounds;
self.maskLayer.contents = (__bridge id)(self.maskContents.CGImage);
self.maskLayer.backgroundColor = [UIColor whiteColor].CGColor;

// 给图片layer提供遮罩的layer
self.imageLayer.mask = self.maskLayer;

// 3秒钟之后做maskLayer动画
[self performSelector:@selector(maskLayerAnimation)
           withObject:nil
           afterDelay:3.f];
       }

- (void)maskLayerAnimation {
self.maskLayer.frame = CGRectMake(50, 50, 200, 200);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;定时执行某方法&quot;&gt;&lt;a href=&quot;#定时执行某方法&quot; class=&quot;headerlink&quot; title=&quot;定时执行某方法&quot;&gt;&lt;/a&gt;定时执行某方法&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;// 定时器
_timer = [NSTimer scheduledTimerWithTimeInterval:1.f
                                          target:self
                                        selector:@selector(timerEvent)
                                        userInfo:nil
                                         repeats:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;随机取值&quot;&gt;&lt;a href=&quot;#随机取值&quot; class=&quot;headerlink&quot; title=&quot;随机取值&quot;&gt;&lt;/a&gt;随机取值&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//随机取0-200中的值
arc4random()%200
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;进度参数&quot;&gt;&lt;a href=&quot;#进度参数&quot; class=&quot;headerlink&quot; title=&quot;进度参数&quot;&gt;&lt;/a&gt;进度参数&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//（取值范围为 %0 ~ %100）
@property (nonatomic, assign) CGFloat  progress;  
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;方法执行开关&quot;&gt;&lt;a href=&quot;#方法执行开关&quot; class=&quot;headerlink&quot; title=&quot;方法执行开关&quot;&gt;&lt;/a&gt;方法执行开关&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#define NO_EXECUTE  0  // 不执行
#define EXECUTE     1  // 执行

// 不执行
if (NO_EXECUTE) {
....
}

// 执行
if (EXECUTE) {
.....
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;动画执行与最终设定&quot;&gt;&lt;a href=&quot;#动画执行与最终设定&quot; class=&quot;headerlink&quot; title=&quot;动画执行与最终设定&quot;&gt;&lt;/a&gt;动画执行与最终设定&lt;/h1&gt;&lt;p&gt;此类动画只是一种提交，并没有最终改变layer的设定。如果结束后，会很快返回到原先的设定。所以要在动画执行前设定好layer值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 设定layer动画结束后的contents值
self.imageLayer.contents = (__bridge id)([UIImage imageNamed:@&amp;quot;结束图片&amp;quot;].CGImage);
self.imageLayer.bounds   = CGRectMake(0, 0, 302/2.f, 707/2.f);

// 让layer开始执行动画
[self.imageLayer addAnimation:groupAnimation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CALayer简介&quot;&gt;&lt;a href=&quot;#CALayer简介&quot; class=&quot;headerlink&quot; title=&quot;CALayer简介&quot;&gt;&lt;/a&gt;CALayer简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CALayer一般作为UIView的容器而使用&lt;/li&gt;
&lt;li&gt;CAL
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_CALayer" scheme="http://jackliu17.github.io/tags/iOS-CALayer/"/>
    
      <category term="iOS_image" scheme="http://jackliu17.github.io/tags/iOS-image/"/>
    
  </entry>
  
  <entry>
    <title>iOS绘图API演示</title>
    <link href="http://jackliu17.github.io/2016/05/07/iOS%E7%BB%98%E5%9B%BEAPI%E6%BC%94%E7%A4%BA/"/>
    <id>http://jackliu17.github.io/2016/05/07/iOS绘图API演示/</id>
    <published>2016-05-07T05:51:59.000Z</published>
    <updated>2016-05-07T06:00:46.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;绘制直线&quot;&gt;&lt;a href=&quot;#绘制直线&quot; class=&quot;headerlink&quot; title=&quot;绘制直线&quot;&gt;&lt;/a&gt;绘制直线&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_drawline.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class DrawLinesView: UIView {

// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
override func drawRect(rect: CGRect) {
    // Drawing code

    //设定绘画环境
    let context = UIGraphicsGetCurrentContext()

    //绘画起点
    CGContextMoveToPoint(context, 100, 100)
    //绘画终点
    CGContextAddLineToPoint(context, 100, 200)
     //绘画终点
    CGContextAddLineToPoint(context, 200, 200)

    //绘画起点
    CGContextMoveToPoint(context, 100, 300)
      //绘画终点
    CGContextAddLineToPoint(context, 100, 400)
      //绘画终点
    CGContextAddLineToPoint(context, 200, 500)

    //设定颜色
    CGContextSetRGBStrokeColor(context, 1, 0, 1, 1)
    //设定线条宽度
    CGContextSetLineWidth(context, 5)
    //绘制线条
    CGContextStrokePath(context)

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;绘制矩形&quot;&gt;&lt;a href=&quot;#绘制矩形&quot; class=&quot;headerlink&quot; title=&quot;绘制矩形&quot;&gt;&lt;/a&gt;绘制矩形&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_drawRect.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;import UIKit

class DrawRectView: UIView {

// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
override func drawRect(rect: CGRect) {
    // Drawing code
//设定绘画环境
let context = UIGraphicsGetCurrentContext()
    //加入矩形
    CGContextAddRect(context, CGRect(x:100,y:100,width: 100,height: 100))
    //填充颜色
    CGContextSetRGBFillColor(context, 1, 0, 0, 1)
    //绘制矩形
    CGContextFillPath(context)

    //设置外框的宽度
    CGContextSetLineWidth(context, 5)
    //设置外框颜色
    CGContextSetRGBStrokeColor(context,0 ,1, 0, 1)
    //绘制外框
    CGContextStrokeRect(context, CGRect(x: 100, y: 100, width: 100, height: 100))

}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;绘制圆形&quot;&gt;&lt;a href=&quot;#绘制圆形&quot; class=&quot;headerlink&quot; title=&quot;绘制圆形&quot;&gt;&lt;/a&gt;绘制圆形&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_drawCircle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;import UIKit

class DrawCircle: UIView { 
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
override func drawRect(rect: CGRect) {
    // Drawing code

let context = UIGraphicsGetCurrentContext()

    //加入圆形
    CGContextAddArc(context, 150, 200, 100, 0, 3.141592653 * 2, 0)
    //填充颜色
    CGContextSetRGBFillColor(context, 1, 0, 0, 1)
    //开始绘制填充
    CGContextFillPath(context)

    //加入圆形
    CGContextAddArc(context, 150, 200, 100, 0, 3.141592653 * 2, 0)
    //设定宽度
    CGContextSetLineWidth(context, 10)
    //绘制
    CGContextStrokePath(context)

    //加入椭圆
    CGContextAddEllipseInRect(context, CGRect(x: 50, y: 400, width: 200, height: 100))
    //绘制
    CGContextStrokePath(context)
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;绘制图片&quot;&gt;&lt;a href=&quot;#绘制图片&quot; class=&quot;headerlink&quot; title=&quot;绘制图片&quot;&gt;&lt;/a&gt;绘制图片&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_drawImage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-3&quot;&gt;&lt;a href=&quot;#代码-3&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;import UIKit

class DrawImageView: UIView {

// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
override func drawRect(rect: CGRect) {
    // Drawing code

    var uiImage:CGImageRef?

    uiImage = UIImage(named: &amp;quot;girl.jpg&amp;quot;)?.CGImage

    let context = UIGraphicsGetCurrentContext()

    //context状态的维持和释放，不影响其他图像的绘制
    CGContextSaveGState(context)

    //没有如下这两个图像会翻转
    CGContextTranslateCTM(context, 10, 400)
    CGContextScaleCTM(context, 1, -1)
    CGContextDrawImage(context, CGRect(x: 0,y: 0,width: 200,height: 200), uiImage)
    CGContextRestoreGState(context)

    CGContextStrokeRect(context, CGRect(x: 50, y: 100, width: 100, height: 100))
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;绘图板&quot;&gt;&lt;a href=&quot;#绘图板&quot; class=&quot;headerlink&quot; title=&quot;绘图板&quot;&gt;&lt;/a&gt;绘图板&lt;/h1&gt;&lt;h2 id=&quot;代码-4&quot;&gt;&lt;a href=&quot;#代码-4&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;import UIKit

class DrawBoardView: UIView {

var path = CGPathCreateMutable()

override func touchesBegan(touches: Set&amp;lt;UITouch&amp;gt;, withEvent event: UIEvent?) {

    let p = (touches as NSSet).anyObject()?.locationInView(self)

    CGPathMoveToPoint(path, nil, p!.x, p!.y)

}

override func touchesMoved(touches: Set&amp;lt;UITouch&amp;gt;, withEvent event: UIEvent?) {

    let p = (touches as NSSet).anyObject()?.locationInView(self)

    CGPathAddLineToPoint(path, nil, p!.x, p!.y)

    setNeedsDisplay()

}

// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
override func drawRect(rect: CGRect) {
    // Drawing code
    let context = UIGraphicsGetCurrentContext()
    CGContextAddPath(context, path)
    CGContextStrokePath(context)

}

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;怎么清空画板&quot;&gt;&lt;a href=&quot;#怎么清空画板&quot; class=&quot;headerlink&quot; title=&quot;怎么清空画板&quot;&gt;&lt;/a&gt;怎么清空画板&lt;/h1&gt;&lt;p&gt;1.重新运行程序即可清空&lt;br&gt;2.设置个按钮点击事件实现清空之前所有操作&lt;br&gt;3.使用CGContextClearRect，&lt;br&gt;4.重新初始化path，这样重画的时候不会检测到之前有线条的path，画面就自动清空了&lt;/p&gt;
&lt;h1 id=&quot;橡皮擦功能&quot;&gt;&lt;a href=&quot;#橡皮擦功能&quot; class=&quot;headerlink&quot; title=&quot;橡皮擦功能&quot;&gt;&lt;/a&gt;橡皮擦功能&lt;/h1&gt;&lt;p&gt;较粗的和背景颜色同样的线条&lt;/p&gt;
&lt;h1 id=&quot;绘制图像时解决翻转问题&quot;&gt;&lt;a href=&quot;#绘制图像时解决翻转问题&quot; class=&quot;headerlink&quot; title=&quot;绘制图像时解决翻转问题&quot;&gt;&lt;/a&gt;绘制图像时解决翻转问题&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;CGContextTranslateCTM(context, 10, 400)
CGContextScaleCTM(context, 1, -1)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;context状态的维持和释放&quot;&gt;&lt;a href=&quot;#context状态的维持和释放&quot; class=&quot;headerlink&quot; title=&quot;context状态的维持和释放&quot;&gt;&lt;/a&gt;context状态的维持和释放&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//context状态的维持和释放，不影响其他图像的绘制
CGContextSaveGState(context)
.............绘制代码
CGContextRestoreGState(context)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;setNeedsDisplay&quot;&gt;&lt;a href=&quot;#setNeedsDisplay&quot; class=&quot;headerlink&quot; title=&quot;setNeedsDisplay()&quot;&gt;&lt;/a&gt;setNeedsDisplay()&lt;/h1&gt;&lt;p&gt;执行这个方法时会调用drawRect重新绘图&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;绘制直线&quot;&gt;&lt;a href=&quot;#绘制直线&quot; class=&quot;headerlink&quot; title=&quot;绘制直线&quot;&gt;&lt;/a&gt;绘制直线&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_drawline.p
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_image" scheme="http://jackliu17.github.io/tags/iOS-image/"/>
    
  </entry>
  
  <entry>
    <title>使用带粒子效果的CAEmitterLayer</title>
    <link href="http://jackliu17.github.io/2016/05/06/%E4%BD%BF%E7%94%A8%E5%B8%A6%E7%B2%92%E5%AD%90%E6%95%88%E6%9E%9C%E7%9A%84CAEmitterLayer/"/>
    <id>http://jackliu17.github.io/2016/05/06/使用带粒子效果的CAEmitterLayer/</id>
    <published>2016-05-06T06:34:55.000Z</published>
    <updated>2016-05-06T06:36:05.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;用CAEmitterLayer产生粒子效果&quot;&gt;&lt;a href=&quot;#用CAEmitterLayer产生粒子效果&quot; class=&quot;headerlink&quot; title=&quot;用CAEmitterLayer产生粒子效果&quot;&gt;&lt;/a&gt;用CAEmitterLayer产生粒子效果&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CAEmitterLayer的用途&lt;/li&gt;
&lt;li&gt;CAEmitterLayer的一些重要参数&lt;/li&gt;
&lt;li&gt;为什么要使用CAEmitterLayer&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
// 创建出Layer
CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];
// 显示边框
emitterLayer.borderWidth = 1.f;

// 给定尺寸
emitterLayer.frame = CGRectMake(100, 100, 100, 100);

// 发射点
emitterLayer.emitterPosition = CGPointMake(0, 0);

// 发射模式
emitterLayer.emitterMode = kCAEmitterLayerSurface;

// 发射形状
emitterLayer.emitterShape = kCAEmitterLayerLine;

// 添加layer
[self.view.layer addSublayer:emitterLayer];

// 创建粒子
CAEmitterCell *cell = [CAEmitterCell emitterCell];

// 粒子产生率
cell.birthRate = 10.f;

// 粒子生命周期
cell.lifetime = 10.f;

// 速度值
cell.velocity = 10;

// 速度值的微调值
cell.velocityRange = 3.f;

// y轴加速度
cell.yAcceleration = 2.f;

// 发射角度
cell.emissionRange = 4.f * M_1_PI;

// 设置粒子颜色
cell.color = [UIColor blackColor].CGColor;

// 设置图片
cell.contents = (__bridge id)([UIImage imageNamed:@&amp;quot;snow&amp;quot;].CGImage);

// 让CAEmitterCell与CAEmitterLayer产生关联
emitterLayer.emitterCells = @[cell];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;封装CAEmitterLayer&quot;&gt;&lt;a href=&quot;#封装CAEmitterLayer&quot; class=&quot;headerlink&quot; title=&quot;封装CAEmitterLayer&quot;&gt;&lt;/a&gt;封装CAEmitterLayer&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;替换CAEmitterLayer成UIView子类的backedLayer&lt;/li&gt;
&lt;li&gt;将CAEmitterLayer封装的类作为“抽象”父类&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;p&gt;viewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;CAEmitterLayerView.h&amp;quot;
@interface ViewController ()
@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
CAEmitterLayerView *layerView = [[CAEmitterLayerView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
NSLog(@&amp;quot;%@&amp;quot;, layerView.layer);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CAEmitterLayerView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;CAEmitterLayerView.h&amp;quot;

@interface CAEmitterLayerView () {
CAEmitterLayer  *_emitterLayer;
}
@end

@implementation CAEmitterLayerView

+ (Class)layerClass {
return [CAEmitterLayer class];
}

- (instancetype)initWithFrame:(CGRect)frame {
self = [super initWithFrame:frame];
if (self) {    
    _emitterLayer = (CAEmitterLayer *)self.layer;
}
return self;
}

- (void)show {
}

- (void)hide {
}

- (void)setEmitterLayer:(CAEmitterLayer *)layer {
_emitterLayer = layer;
}

- (CAEmitterLayer *)emitterLayer {
return _emitterLayer;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;封装下雪下雨的粒子效果控件&quot;&gt;&lt;a href=&quot;#封装下雪下雨的粒子效果控件&quot; class=&quot;headerlink&quot; title=&quot;封装下雪下雨的粒子效果控件&quot;&gt;&lt;/a&gt;封装下雪下雨的粒子效果控件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;从封装CAEmitterLayer的“抽象”父类继承的原因&lt;/li&gt;
&lt;li&gt;下雪、下雨效果参数的设置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_CAEmitterLayer.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;p&gt;viewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];

UIImageView *alphaView1 = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
alphaView1.image        = [UIImage imageNamed:@&amp;quot;alpha&amp;quot;];

// 添加下雪效果
CAEmitterLayerView *snowView = [[SnowView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
snowView.maskView            = alphaView1;
[self.view addSubview:snowView];
[snowView show];

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SnowView.m (继承CAEmitterLayerView，见上)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;SnowView.h&amp;quot;

@implementation SnowView

- (instancetype)initWithFrame:(CGRect)frame {
self = [super initWithFrame:frame];
if (self) {
    // 初始化设置
    [self setup];
}
return self;
}

- (void)setup {
self.emitterLayer.masksToBounds   = YES;
self.emitterLayer.emitterShape    = kCAEmitterLayerLine;
self.emitterLayer.emitterMode     = kCAEmitterLayerSurface;
self.emitterLayer.emitterSize     = self.frame.size;
self.emitterLayer.emitterPosition = CGPointMake(self.bounds.size.width / 2.f, - 20);
}

- (void)show {
// 配置
CAEmitterCell *snowflake  = [CAEmitterCell emitterCell];
snowflake.birthRate       = 1.f;
snowflake.speed           = 10.f;
snowflake.velocity        = 2.f;
snowflake.velocityRange   = 10.f;
snowflake.yAcceleration   = 10.f;
snowflake.emissionRange   = 0.5 * M_PI;
snowflake.spinRange       = 0.25 * M_PI;
snowflake.contents        = (__bridge id)([UIImage imageNamed:@&amp;quot;snow&amp;quot;].CGImage);
snowflake.color           = [UIColor redColor].CGColor;
snowflake.lifetime        = 60.f;
snowflake.scale           = 0.5;
snowflake.scaleRange      = 0.3;

// 添加动画
self.emitterLayer.emitterCells = @[snowflake];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;指定UIView的layer-class&quot;&gt;&lt;a href=&quot;#指定UIView的layer-class&quot; class=&quot;headerlink&quot; title=&quot;指定UIView的layer class&quot;&gt;&lt;/a&gt;指定UIView的layer class&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;+ (Class)layerClass {
return [CAEmitterLayer class];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用CAEmitterLayer产生粒子效果&quot;&gt;&lt;a href=&quot;#用CAEmitterLayer产生粒子效果&quot; class=&quot;headerlink&quot; title=&quot;用CAEmitterLayer产生粒子效果&quot;&gt;&lt;/a&gt;用CAEmitterLayer产生粒子效果&lt;/
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
  </entry>
  
  <entry>
    <title>缓动函数与关键帧动画</title>
    <link href="http://jackliu17.github.io/2016/05/05/%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/"/>
    <id>http://jackliu17.github.io/2016/05/05/缓动函数与关键帧动画/</id>
    <published>2016-05-05T11:08:35.000Z</published>
    <updated>2016-05-05T11:18:33.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;缓动函数简介&quot;&gt;&lt;a href=&quot;#缓动函数简介&quot; class=&quot;headerlink&quot; title=&quot;缓动函数简介&quot;&gt;&lt;/a&gt;缓动函数简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;缓动函数的动画效果是建立在CALayer层级的关键帧动画基础之上&lt;/li&gt;
&lt;li&gt;缓动函数是一系列模拟物理效果（如抛物线）方程式的统称，用以计算给定两点之间的插值&lt;/li&gt;
&lt;li&gt;两点之间插的值越多，效果越好，但是会耗费更多的性能&lt;/li&gt;
&lt;li&gt;只有理解了缓动函数的原理才有可能写出自己想要的效果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;缓动函数与关键帧动画的联系&quot;&gt;&lt;a href=&quot;#缓动函数与关键帧动画的联系&quot; class=&quot;headerlink&quot; title=&quot;缓动函数与关键帧动画的联系&quot;&gt;&lt;/a&gt;缓动函数与关键帧动画的联系&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;关键帧动画需要提供很多的帧来完善动画效果&lt;/li&gt;
&lt;li&gt;关键帧动画的帧可以通过一定的数学计算来提供需要的帧数&lt;/li&gt;
&lt;li&gt;关键帧动画只需要提供起始点，结束点，就可以通过缓动函数来计算中间“缺失”的帧&lt;/li&gt;
&lt;li&gt;缓动函数可以指定计算出多少帧&lt;/li&gt;
&lt;li&gt;帧数越多，动画越流畅，但同时耗费更多的GPU性能。&lt;strong&gt;1秒钟60帧最多了，写得再大也是浪费GPU&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 添加显示用的view
UIView *showView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
showView.layer.cornerRadius  = 50;
showView.layer.masksToBounds = YES;
showView.backgroundColor     = [UIColor redColor];
[self.view addSubview:showView];

//    // 基本动画类型
//    CABasicAnimation *basicAnimation = [CABasicAnimation animation];
//    basicAnimation.keyPath           = @&amp;quot;position&amp;quot;;
//    basicAnimation.duration          = 4.f;
//
//    // fromValue = A | toValue = B
//    basicAnimation.fromValue = [NSValue valueWithCGPoint:showView.center];
//    basicAnimation.toValue   = [NSValue valueWithCGPoint:CGPointMake(200, 200)];
//
//    showView.center = CGPointMake(200, 200);
//    [showView.layer addAnimation:basicAnimation forKey:nil];

// 关键帧动画类型
CAKeyframeAnimation *keyFrameAnimation = [CAKeyframeAnimation animation];
keyFrameAnimation.keyPath              = @&amp;quot;position&amp;quot;;
keyFrameAnimation.duration             = 4.f;
keyFrameAnimation.values = [YXEasing calculateFrameFromPoint:showView.center
                                                     toPoint:CGPointMake(200, 200)
                                                        func:BounceEaseInOut
                                                  frameCount:30 * 4];
showView.center = CGPointMake(200, 200);
[showView.layer addAnimation:keyFrameAnimation forKey:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用缓动函数模拟弹簧效果&quot;&gt;&lt;a href=&quot;#用缓动函数模拟弹簧效果&quot; class=&quot;headerlink&quot; title=&quot;用缓动函数模拟弹簧效果&quot;&gt;&lt;/a&gt;用缓动函数模拟弹簧效果&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用easeOutElastic函数来创建弹簧效果&lt;/li&gt;
&lt;li&gt;将easeOutElastic创建出来的帧数组添加到关键帧动画中&lt;/li&gt;
&lt;li&gt;弹簧效果用途&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_spring.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;YXEasing.h&amp;quot;
@interface ViewController ()
@property (nonatomic, strong) CALayer *secLayer; // 秒针layer
@property (nonatomic, strong) NSTimer *timer;    // 定时器
@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 创建一个表盘
UIView *showView            = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)];
showView.center             = self.view.center;
showView.layer.borderWidth  = 1.f;
showView.layer.cornerRadius = 150;
showView.layer.borderColor  = [UIColor redColor].CGColor;
[self.view addSubview:showView];

// 创建出秒针layer
self.secLayer                 = [CALayer layer];
self.secLayer.anchorPoint     = CGPointMake(0, 0);
self.secLayer.frame           = CGRectMake(150, 150, 1, 150);
self.secLayer.backgroundColor = [UIColor blackColor].CGColor;
[showView.layer addSublayer:self.secLayer];

// 创建定时器
self.timer = [NSTimer scheduledTimerWithTimeInterval:1.f
                                              target:self
                                            selector:@selector(timerEvent)
                                            userInfo:nil
                                             repeats:YES];
}

- (void)timerEvent {

static int i = 1;

CGFloat oldValue = DEGREES_TO_RADIANS((360 / 60.f) * i++);
CGFloat newValue = DEGREES_TO_RADIANS((360 / 60.f) * i);

// 创建关键帧动画
CAKeyframeAnimation *keyFrameAnimation = [CAKeyframeAnimation animation];
keyFrameAnimation.keyPath              = @&amp;quot;transform.rotation.z&amp;quot;;
keyFrameAnimation.duration             = 0.5;
keyFrameAnimation.values               = [YXEasing calculateFrameFromValue:oldValue
                                                                   toValue:newValue
                                                                      func:ElasticEaseOut
                                                                frameCount:0.5 * 30];

self.secLayer.transform = CATransform3DMakeRotation(newValue, 0, 0, 1);
[self.secLayer addAnimation:keyFrameAnimation forKey:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用缓动函数模拟碰撞效果&quot;&gt;&lt;a href=&quot;#用缓动函数模拟碰撞效果&quot; class=&quot;headerlink&quot; title=&quot;用缓动函数模拟碰撞效果&quot;&gt;&lt;/a&gt;用缓动函数模拟碰撞效果&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用easeOutBounce函数来创建弹簧效果&lt;/li&gt;
&lt;li&gt;将easeOutBounce创建出来的帧数组添加到关键帧动画中&lt;/li&gt;
&lt;li&gt;碰撞效果用途&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
// 创建图片view
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 320, 320)];
imageView.image        = [UIImage imageNamed:@&amp;quot;pic&amp;quot;];
imageView.contentMode  = UIViewContentModeScaleAspectFill;
[self.view addSubview:imageView];

// 创建关键帧动画(移动距离的动画)
CAKeyframeAnimation *keyFrameAnimation = [CAKeyframeAnimation animation];
keyFrameAnimation.keyPath              = @&amp;quot;position&amp;quot;;
keyFrameAnimation.duration             = 2.f;
keyFrameAnimation.values               = \
[YXEasing calculateFrameFromPoint:imageView.center
                          toPoint:CGPointMake(320 / 2.f, 320 / 2.f + 240)
                             func:BounceEaseOut
                       frameCount:2 * 30];

// 添加动画
imageView.center = CGPointMake(320 / 2.f, 320 / 2.f + 240);
[imageView.layer addAnimation:keyFrameAnimation forKey:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;用缓动函数模拟衰减效果&quot;&gt;&lt;a href=&quot;#用缓动函数模拟衰减效果&quot; class=&quot;headerlink&quot; title=&quot;用缓动函数模拟衰减效果&quot;&gt;&lt;/a&gt;用缓动函数模拟衰减效果&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用easeOutCubic函数来创建弹簧效果&lt;/li&gt;
&lt;li&gt;将easeOutCubic创建出来的帧数组添加到关键帧动画中&lt;/li&gt;
&lt;li&gt;衰减效果用途&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;代码-3&quot;&gt;&lt;a href=&quot;#代码-3&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
// 背景变暗的view
UIView *backView         = [[UIView alloc] initWithFrame:self.view.bounds];
backView.backgroundColor = [UIColor blackColor];
backView.alpha           = 0;
[UIView animateWithDuration:1.f animations:^{
    backView.alpha       = 0.3;
}];
[self.view addSubview:backView];

// 创建模拟的菜单
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(320, 0, 320, 568)];
imageView.image        = [UIImage imageNamed:@&amp;quot;pic&amp;quot;];
[self.view addSubview:imageView];

// 创建关键帧动画
CAKeyframeAnimation *keyFrameAnimation = [CAKeyframeAnimation animation];
keyFrameAnimation.keyPath              = @&amp;quot;position&amp;quot;;
keyFrameAnimation.duration             = 1.f;
keyFrameAnimation.values               = \
[YXEasing calculateFrameFromPoint:imageView.center
                          toPoint:CGPointMake(self.view.center.x + 100, self.view.center.y)
                             func:CubicEaseOut
                       frameCount:1 * 30];

// 加载关键帧动画
imageView.center = CGPointMake(self.view.center.x + 100, self.view.center.y);
[imageView.layer addAnimation:keyFrameAnimation forKey:nil];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缓动函数简介&quot;&gt;&lt;a href=&quot;#缓动函数简介&quot; class=&quot;headerlink&quot; title=&quot;缓动函数简介&quot;&gt;&lt;/a&gt;缓动函数简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;缓动函数的动画效果是建立在CALayer层级的关键帧动画基础之上&lt;/li&gt;
&lt;li&gt;缓动函数是一
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
  </entry>
  
  <entry>
    <title>Facebook开源动画库POP实现真实衰减与弹簧动画</title>
    <link href="http://jackliu17.github.io/2016/05/05/Facebook%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93POP%E5%AE%9E%E7%8E%B0%E7%9C%9F%E5%AE%9E%E8%A1%B0%E5%87%8F%E4%B8%8E%E5%BC%B9%E7%B0%A7%E5%8A%A8%E7%94%BB/"/>
    <id>http://jackliu17.github.io/2016/05/05/Facebook开源动画库POP实现真实衰减与弹簧动画/</id>
    <published>2016-05-05T04:36:15.000Z</published>
    <updated>2016-05-05T04:37:27.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;POP动画引擎简介&quot;&gt;&lt;a href=&quot;#POP动画引擎简介&quot; class=&quot;headerlink&quot; title=&quot;POP动画引擎简介&quot;&gt;&lt;/a&gt;POP动画引擎简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;POP动画引擎是Facebook公司开源的&lt;/li&gt;
&lt;li&gt;POP动画引擎主要实现了真实物理系的动画效果(弹簧效果与衰减效果)&lt;/li&gt;
&lt;li&gt;POP动画引擎的动画效果非常流畅，因为它使用了CADisplayLink来刷新画面(帧)&lt;/li&gt;
&lt;li&gt;POP动画引擎自成体系，与系统的CoreAnimation有着很大的区别，但使用非常类似&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;POP动画引擎中Layer与CALayer的区别&quot;&gt;&lt;a href=&quot;#POP动画引擎中Layer与CALayer的区别&quot; class=&quot;headerlink&quot; title=&quot;POP动画引擎中Layer与CALayer的区别&quot;&gt;&lt;/a&gt;POP动画引擎中Layer与CALayer的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用POP动画与使用CALayer动画非常相似&lt;/li&gt;
&lt;li&gt;POP动画的执行没有中间状态&lt;/li&gt;
&lt;li&gt;POP动画是对CALayer动画的扩充，但不能实现所有的CALayer的动画效果&lt;/li&gt;
&lt;li&gt;POP动画可以作用在任何对象上，不仅仅是CALayer&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;POP动画引擎中Layer与CALayer的区别-1&quot;&gt;&lt;a href=&quot;#POP动画引擎中Layer与CALayer的区别-1&quot; class=&quot;headerlink&quot; title=&quot;POP动画引擎中Layer与CALayer的区别&quot;&gt;&lt;/a&gt;POP动画引擎中Layer与CALayer的区别&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/pop.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;用POP动画引擎实现衰减动画&quot;&gt;&lt;a href=&quot;#用POP动画引擎实现衰减动画&quot; class=&quot;headerlink&quot; title=&quot;用POP动画引擎实现衰减动画&quot;&gt;&lt;/a&gt;用POP动画引擎实现衰减动画&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;衰减动画由POPDecayAnimation来实现&lt;/li&gt;
&lt;li&gt;需要精确计算停止运动瞬间的加速度才能够用衰减动画做出真实的效果&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;用POP动画引擎实现弹簧动画&quot;&gt;&lt;a href=&quot;#用POP动画引擎实现弹簧动画&quot; class=&quot;headerlink&quot; title=&quot;用POP动画引擎实现弹簧动画&quot;&gt;&lt;/a&gt;用POP动画引擎实现弹簧动画&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;弹簧动画由POPSpringAnimation来实现&lt;/li&gt;
&lt;li&gt;弹簧的质量速度时间等值都是可以设置的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For more information , go to &lt;a href=&quot;https://github.com/facebook/pop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/facebook/pop&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;POP动画引擎简介&quot;&gt;&lt;a href=&quot;#POP动画引擎简介&quot; class=&quot;headerlink&quot; title=&quot;POP动画引擎简介&quot;&gt;&lt;/a&gt;POP动画引擎简介&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;POP动画引擎是Facebook公司开源的&lt;/li&gt;
&lt;li&gt;POP动画
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
  </entry>
  
  <entry>
    <title>使用maskView设计动画及遮盖</title>
    <link href="http://jackliu17.github.io/2016/05/03/%E4%BD%BF%E7%94%A8maskView%E8%AE%BE%E8%AE%A1%E5%8A%A8%E7%94%BB%E5%8F%8A%E9%81%AE%E7%9B%96/"/>
    <id>http://jackliu17.github.io/2016/05/03/使用maskView设计动画及遮盖/</id>
    <published>2016-05-03T11:47:38.000Z</published>
    <updated>2016-05-03T11:50:53.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;maskView（maskLayer）基本原理&quot;&gt;&lt;a href=&quot;#maskView（maskLayer）基本原理&quot; class=&quot;headerlink&quot; title=&quot;maskView（maskLayer）基本原理&quot;&gt;&lt;/a&gt;maskView（maskLayer）基本原理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;png图片透明像素的原理 （只有png才有透明度概念，jpg没有）&lt;/li&gt;
&lt;li&gt;maskView（maskLayer）可类比于多张png图片的叠加遮罩，原理类似&lt;/li&gt;
&lt;li&gt;maskView是iOS8以上才有的，如果要考虑兼容低版本，用maskLayer替换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/maskerView.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;// 使用maskView的情况

UIImageView *mask = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, width, width)];
mask.image = [UIImage imageNamed:@&amp;quot;mask&amp;quot;];

self.addImageView = [[UIImageView alloc] initWithFrame:CGRectMake(20, 20 + (width + 20) * 2, width, width)];
self.addImageView.image = [UIImage imageNamed:@&amp;quot;base&amp;quot;];
// maskView并不能用addSubview来添加遮罩,这点千万注意
self.addImageView.maskView = mask;
[self.view addSubview:self.addImageView];

//赋值给上面的mask，在iOS8以下采用
//self.addImageView.layer.mask
//CALayer *layer,
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;maskView配合CAGradientLayer的使用&quot;&gt;&lt;a href=&quot;#maskView配合CAGradientLayer的使用&quot; class=&quot;headerlink&quot; title=&quot;maskView配合CAGradientLayer的使用&quot;&gt;&lt;/a&gt;maskView配合CAGradientLayer的使用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;用CAGradientLayer直接产生带透明像素通道的layer&lt;/li&gt;
&lt;li&gt;用maskView直接加载带CAGradientLayer的view&lt;/li&gt;
&lt;li&gt;可以通过对CAGradientLayer进行动画的操作实现动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 加载图片
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(20, 20, 200, 200)];
imageView.image        = [UIImage imageNamed:@&amp;quot;base&amp;quot;];
[self.view addSubview:imageView];

// 创建出CAGradientLayer
CAGradientLayer *gradientLayer = [CAGradientLayer layer];
gradientLayer.frame            = imageView.bounds;
gradientLayer.colors           = @[(__bridge id)[UIColor clearColor].CGColor,
                                   (__bridge id)[UIColor blackColor].CGColor,
                                   (__bridge id)[UIColor clearColor].CGColor];
gradientLayer.locations        = @[@(0.25), @(0.5), @(0.75)];
gradientLayer.startPoint       = CGPointMake(0, 0);
gradientLayer.endPoint         = CGPointMake(1, 0);

// 容器view --&amp;gt; 用于加载创建出的CAGradientLayer
UIView *containerView = [[UIView alloc] initWithFrame:imageView.bounds];
[containerView.layer addSublayer:gradientLayer];

// 设定maskView
imageView.maskView  = containerView;

CGRect frame        = containerView.frame;
frame.origin.x     -= 200;

// 重新赋值
containerView.frame = frame;

// 给maskView做动画效果
[UIView animateWithDuration:3.f animations:^{
    // 改变位移
    CGRect frame        = containerView.frame;
    frame.origin.x     += 400;

    // 重新赋值
    containerView.frame = frame;
}];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;maskView配合带alpha通道图片的使用&quot;&gt;&lt;a href=&quot;#maskView配合带alpha通道图片的使用&quot; class=&quot;headerlink&quot; title=&quot;maskView配合带alpha通道图片的使用&quot;&gt;&lt;/a&gt;maskView配合带alpha通道图片的使用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;直接使用带alpha通道的png图片比用CAGradientLayer的方式更加高效&lt;/li&gt;
&lt;li&gt;可以使用技巧在maskView上添加多张图片&lt;/li&gt;
&lt;li&gt;在maskView中做简单的动画&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];

// 前景图
UIImageView *background = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
background.image        = [UIImage imageNamed:@&amp;quot;base&amp;quot;];
background.center       = self.view.center;
[self.view addSubview:background];


// 背景图
UIImageView *upGround = [[UIImageView alloc] initWithFrame:background.frame];
upGround.image        = [UIImage imageNamed:@&amp;quot;background&amp;quot;];
[self.view addSubview:upGround];


// maskView
UIView *mask      = [[UIView alloc] initWithFrame:upGround.bounds];
upGround.maskView = mask;


// 图片1
UIImageView *picOne = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 400)];
picOne.image        = [UIImage imageNamed:@&amp;quot;1&amp;quot;];
[mask addSubview:picOne];


// 图片2
UIImageView *picTwo = [[UIImageView alloc] initWithFrame:CGRectMake(100, -200, 100, 400)];
picTwo.image        = [UIImage imageNamed:@&amp;quot;2&amp;quot;];
[mask addSubview:picTwo];


// 动画
[UIView animateWithDuration:4.f delay:5.f options:0 animations:^{
    picOne.y -= 400;
    picTwo.y += 400;
} completion:^(BOOL finished) {

}];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;设计文本横向渐变消失的控件&quot;&gt;&lt;a href=&quot;#设计文本横向渐变消失的控件&quot; class=&quot;headerlink&quot; title=&quot;设计文本横向渐变消失的控件&quot;&gt;&lt;/a&gt;设计文本横向渐变消失的控件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;接口的设计&lt;/li&gt;
&lt;li&gt;封装CAGradientLayer用以提供mask遮罩&lt;/li&gt;
&lt;li&gt;动画样式的分析与设计&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;设计动画函数的格式&quot;&gt;&lt;a href=&quot;#设计动画函数的格式&quot; class=&quot;headerlink&quot; title=&quot;设计动画函数的格式&quot;&gt;&lt;/a&gt;设计动画函数的格式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;// - (void)fadeRight
//将持续时间和是否执行动画设计进去
- (void)fadeRightWithDuration:(NSTimeInterval)duration animated:(BOOL)animated;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;代码-3&quot;&gt;&lt;a href=&quot;#代码-3&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame {
self = [super initWithFrame:frame];
if (self) {

    // 创建出label
    [self createLabel:self.bounds];

    // 创建出mask
    [self createMask:self.bounds];

}
return self;
}

- (void)createLabel:(CGRect)frame {
self.label               = [[UILabel alloc] initWithFrame:frame];
self.label.font          = [UIFont systemFontOfSize:30.f];
self.label.textAlignment = NSTextAlignmentCenter;
self.label.textColor     = [UIColor redColor];

[self addSubview:self.label];
}

- (void)createMask:(CGRect)frame {

// 创建出渐变的layer
CAGradientLayer *gradientLayer = [CAGradientLayer layer];
gradientLayer.frame            = frame;
gradientLayer.colors           = @[(__bridge id)[UIColor clearColor].CGColor,
                                   (__bridge id)[UIColor blackColor].CGColor,
                                   (__bridge id)[UIColor blackColor].CGColor,
                                   (__bridge id)[UIColor clearColor].CGColor];
gradientLayer.locations        = @[@(0.01), @(0.1), @(0.9), @(0.99)];
gradientLayer.startPoint       = CGPointMake(0, 0);
gradientLayer.endPoint         = CGPointMake(1, 0);

// 创建并接管mask
self.mask     = [[UIView alloc] initWithFrame:frame];

// mask获取渐变layer
[self.mask.layer addSublayer:gradientLayer];

self.maskView = self.mask;
}

- (void)fadeRight {

[UIView animateWithDuration:3.f animations:^{
    CGRect frame    = self.mask.frame;
    frame.origin.x += frame.size.width;

    self.mask.frame = frame;
}];

}

//重写setter,getter方法

@synthesize text = _text;
- (void)setText:(NSString *)text {
_text           = text;
self.label.text = text;
}
- (NSString *)text {
return _text;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;maskView（maskLayer）基本原理&quot;&gt;&lt;a href=&quot;#maskView（maskLayer）基本原理&quot; class=&quot;headerlink&quot; title=&quot;maskView（maskLayer）基本原理&quot;&gt;&lt;/a&gt;maskView（maskLaye
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
      <category term="iOS_image" scheme="http://jackliu17.github.io/tags/iOS-image/"/>
    
  </entry>
  
  <entry>
    <title>iOS模糊效果的使用</title>
    <link href="http://jackliu17.github.io/2016/05/01/iOS%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://jackliu17.github.io/2016/05/01/iOS模糊效果的使用/</id>
    <published>2016-05-01T07:04:23.000Z</published>
    <updated>2016-05-01T08:54:36.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;CoreImage中的模糊滤镜&quot;&gt;&lt;a href=&quot;#CoreImage中的模糊滤镜&quot; class=&quot;headerlink&quot; title=&quot;CoreImage中的模糊滤镜&quot;&gt;&lt;/a&gt;CoreImage中的模糊滤镜&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CoreImage是苹果用来简化图片处理的框架&lt;/li&gt;
&lt;li&gt;CIImage, CIFilter与CIContext三者之间的联系&lt;/li&gt;
&lt;li&gt;CIGaussianBlur中可以设置的参数&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {

[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 原始图片
UIImage *image = [UIImage imageNamed:@&amp;quot;girl.jpg&amp;quot;];

/*......coreImage部分........ */

//CIImage
CIImage *ciImage = [[CIImage alloc]initWithImage:image];

//CIFilter
CIFilter *blurFilter = [CIFilter filterWithName:@&amp;quot;CIGaussianBlur&amp;quot;];

//将图片输入到滤镜中
[blurFilter setValue:ciImage forKey:kCIInputImageKey];

//    //设置的模糊程度
//    [blurFilter setValue:@(100) forKey:@&amp;quot;inputRadius&amp;quot;];
//

//将处理好的图片输出
CIImage *outCiImage = [blurFilter valueForKey:kCIOutputImageKey];

NSLog(@&amp;quot;%@&amp;quot;,[blurFilter attributes]);

//CIContext
CIContext *context = [CIContext contextWithOptions:nil];

//获取CGImage句柄
CGImageRef outCGImage = [context createCGImage:outCiImage
                                      fromRect:[outCiImage extent]];
//最终获取到图片
UIImage *blurImage = [UIImage imageWithCGImage:outCGImage];

//释放CGImage句柄
CGImageRelease(outCGImage);

/*.............. */

//初始化UIImageView
UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 590/2.f, 988/2.f)];
imageView.image = blurImage;
imageView.center = self.view.center;
[self.view addSubview:imageView];

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;UIImage-ImageEffects的category模糊效果&quot;&gt;&lt;a href=&quot;#UIImage-ImageEffects的category模糊效果&quot; class=&quot;headerlink&quot; title=&quot;UIImage + ImageEffects的category模糊效果&quot;&gt;&lt;/a&gt;UIImage + ImageEffects的category模糊效果&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;UIImage + ImageEffects是Accelerate框架中的内容&lt;/li&gt;
&lt;li&gt;UIImage + ImageEffects的模糊效果非常美观&lt;/li&gt;
&lt;li&gt;修改过的UIImage + ImageEffects可以对图片进行局部模糊&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码-1&quot;&gt;&lt;a href=&quot;#代码-1&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.


//原始图片
UIImage *sourceImage = [UIImage imageNamed:@&amp;quot;normal.png&amp;quot;];

//对图片进行部分模糊
//UIImage *blurImage = [sourceImage blurImage];
UIImage *blurImage = [sourceImage blurImageAtFrame:CGRectMake(0, 100, sourceImage.size.width, sourceImage.size.height/2.f)];


//加载图片
UIImageView *imageView = [[UIImageView alloc]initWithImage:blurImage];
[self.view addSubview:imageView];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;iOS8中UIVisualEffectView模糊效果的使用&quot;&gt;&lt;a href=&quot;#iOS8中UIVisualEffectView模糊效果的使用&quot; class=&quot;headerlink&quot; title=&quot;iOS8中UIVisualEffectView模糊效果的使用&quot;&gt;&lt;/a&gt;iOS8中UIVisualEffectView模糊效果的使用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;UIVisualEffectView的模糊效果是即使渲染的&lt;/li&gt;
&lt;li&gt;要注意处理在UIVisualEffectView之上的文本显示&lt;/li&gt;
&lt;li&gt;只能在iOS8以上才能够使用UIVisualEffectView&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_image001_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码-2&quot;&gt;&lt;a href=&quot;#代码-2&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

//添加展示背景，用以显示动态模糊
self.scrollView = [[UIScrollView alloc]initWithFrame:self.view.bounds];
UIImageView *imageView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&amp;quot;girl.jpg&amp;quot;]];
self.scrollView.contentSize = imageView.image.size;
self.scrollView.bounces = NO;
[self.scrollView addSubview:imageView];
[self.view addSubview:self.scrollView];

/* 添加模糊效果*/

//1. 创建模糊view
UIVisualEffectView *effectView = [[UIVisualEffectView alloc]
                              initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]];

//2.设定尺寸
effectView.frame = CGRectMake(0, 100, 320, 200);

//3.添加到view当中
[self.view addSubview:effectView];

//添加显示文本
UILabel *label = [[UILabel alloc]initWithFrame:effectView.bounds];
label.text = @&amp;quot;I love you&amp;quot;;
label.font = [UIFont systemFontOfSize:50.f];
label.textAlignment = NSTextAlignmentCenter;
//[effectView.contentView addSubview:label];

//添加模糊子view的UIVisualEffectView

//1. 创建出子模糊view
UIVisualEffectView *subEffectView = [[UIVisualEffectView alloc]
                                     initWithEffect:[UIVibrancyEffect effectForBlurEffect:(UIBlurEffect *)effectView.effect]];

//2. 设定尺寸
subEffectView.frame = effectView.bounds;

//3. 将子模糊view添加到effectView的contentView才能生效
[effectView.contentView addSubview:subEffectView];

//4. 添加要显示的view来达到特殊的效果
[subEffectView.contentView addSubview:label];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;设计下载图片后自动模糊的控件&quot;&gt;&lt;a href=&quot;#设计下载图片后自动模糊的控件&quot; class=&quot;headerlink&quot; title=&quot;设计下载图片后自动模糊的控件&quot;&gt;&lt;/a&gt;设计下载图片后自动模糊的控件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;用KVO监听下载完成后的事件&lt;/li&gt;
&lt;li&gt;在子线程中进行渲染，主线程中进行图片的加载&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码-3&quot;&gt;&lt;a href=&quot;#代码-3&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;p&gt;viewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];

NSString *picUrlString = @&amp;quot;http://f.hiphotos.baidu.com/image/pic/item/0d338744ebf81a4ce4ea4cd4d52a6059242da6d7.jpg&amp;quot;;

BlurDownloadPicView *blurDownloadView = [[BlurDownloadPicView alloc]initWithFrame:CGRectMake(0, 0, 320, 400)];
blurDownloadView.center = self.view.center;
blurDownloadView.pictureUrlString = picUrlString;
//内容填充模式(图片怎样填入)
blurDownloadView.contentMode = UIViewContentModeScaleAspectFit;
[self.view addSubview:blurDownloadView];

[blurDownloadView startProgress];

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BlurDownloadPicView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface BlurDownloadPicView ()
@property (nonatomic,strong) UIImageView *imageView;
@end
@implementation BlurDownloadPicView

- (instancetype)initWithFrame:(CGRect)frame {

self = [super initWithFrame:frame];
if (self) {
    //初始化控件
    self.imageView = [[UIImageView alloc]initWithFrame:self.bounds];
    self.imageView.alpha = 0.f;
    [self addSubview:self.imageView];
}
return self;
}

- (void)startProgress{

if (self.pictureUrlString) {

    //子线程
    [GCDQueue executeInGlobalQueue:^{
        //创建请求
        NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:self.pictureUrlString]];
        //因为是同步请求,会阻塞主线程(mainQueue)
        NSData *data = [NSURLConnection sendSynchronousRequest:request
                                             returningResponse:nil
                                                         error:nil];
        //获取图片
        UIImage *image = [[UIImage alloc]initWithData:data];
        //对图片进行模糊
        UIImage *blurImage = [image blurImage];
        //主线程
        [GCDQueue executeInMainQueue:^{
            //加载图片
            self.imageView.image = blurImage;
            //动画效果
            [UIView animateWithDuration:3.f
                             animations:^{
                                 self.imageView.alpha = 1.f;
                             }];
        }];

    }];
}
}

@synthesize contentMode = _contentMode;

- (void)setContentMode:(UIViewContentMode)contentMode {
_contentMode = contentMode;
self.imageView.contentMode = contentMode;
}

- (UIViewContentMode)contentMode {
return _contentMode;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;内容填充模式contentMode&quot;&gt;&lt;a href=&quot;#内容填充模式contentMode&quot; class=&quot;headerlink&quot; title=&quot;内容填充模式contentMode&quot;&gt;&lt;/a&gt;内容填充模式contentMode&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//内容填充模式(图片怎样填入)
blurDownloadView.contentMode = UIViewContentModeScaleAspectFit;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;透明度渐变采用动画设定alpha值&quot;&gt;&lt;a href=&quot;#透明度渐变采用动画设定alpha值&quot; class=&quot;headerlink&quot; title=&quot;透明度渐变采用动画设定alpha值&quot;&gt;&lt;/a&gt;透明度渐变采用动画设定alpha值&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;[UIView animateWithDuration:3.f
                             animations:^{
                                 self.imageView.alpha = 1.f;
                             }];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CoreImage中的模糊滤镜&quot;&gt;&lt;a href=&quot;#CoreImage中的模糊滤镜&quot; class=&quot;headerlink&quot; title=&quot;CoreImage中的模糊滤镜&quot;&gt;&lt;/a&gt;CoreImage中的模糊滤镜&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CoreImage是苹果
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_image" scheme="http://jackliu17.github.io/tags/iOS-image/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目9.三级视图控制器</title>
    <link href="http://jackliu17.github.io/2016/04/30/iOS%E9%A1%B9%E7%9B%AE9-%E4%B8%89%E7%BA%A7%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>http://jackliu17.github.io/2016/04/30/iOS项目9-三级视图控制器/</id>
    <published>2016-04-30T12:14:13.000Z</published>
    <updated>2016-04-30T12:15:50.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOSproj00901.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;项目分析&quot;&gt;&lt;a href=&quot;#项目分析&quot; class=&quot;headerlink&quot; title=&quot;项目分析&quot;&gt;&lt;/a&gt;项目分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOSproj00902.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;三级视图控制器&quot;&gt;&lt;a href=&quot;#三级视图控制器&quot; class=&quot;headerlink&quot; title=&quot;三级视图控制器&quot;&gt;&lt;/a&gt;三级视图控制器&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;标签控制器 -&amp;gt; 导航控制器 -&amp;gt; 视图控制器，这就叫三级视图控制器&lt;/li&gt;
&lt;li&gt;一个导航控制器对应于一个视图控制器，&lt;/li&gt;
&lt;li&gt;标签控制器是管理固定的几个视图控制器，子控制器是并列的。&lt;/li&gt;
&lt;li&gt;UITabBarController用数组管理视图控制器，而导航控制器所管理的视图控制器之间的关系是上下级关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;设置window&quot;&gt;&lt;a href=&quot;#设置window&quot; class=&quot;headerlink&quot; title=&quot;设置window&quot;&gt;&lt;/a&gt;设置window&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
self.window.backgroundColor = [UIColor whiteColor];
[self.window makeKeyAndVisible];
RootViewController *rootVC = [[RootViewController alloc] init];
//权限最高的给根视图控制器
self.window.rootViewController = rootVC; 
// Override point for customization after application launch.
return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;数组赋值示例&quot;&gt;&lt;a href=&quot;#数组赋值示例&quot; class=&quot;headerlink&quot; title=&quot;数组赋值示例&quot;&gt;&lt;/a&gt;数组赋值示例&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;NSArray *vcArray = @[profielVC,messageVC,colaVC,userVC,moreVC];
NSMutableArray *tabArray = [NSMutableArray arrayWithCapacity:vcArray.count];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;背景颜色赋值为图片&quot;&gt;&lt;a href=&quot;#背景颜色赋值为图片&quot; class=&quot;headerlink&quot; title=&quot;背景颜色赋值为图片&quot;&gt;&lt;/a&gt;背景颜色赋值为图片&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;_tabBarView.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&amp;quot;mask_navbar&amp;quot;]];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;UIButton设tag值&quot;&gt;&lt;a href=&quot;#UIButton设tag值&quot; class=&quot;headerlink&quot; title=&quot;UIButton设tag值&quot;&gt;&lt;/a&gt;UIButton设tag值&lt;/h1&gt;&lt;pre&gt;&lt;code&gt; //区分是点击了哪个button
//iOS中100以前的tag值有特殊用法，所以最好在100以后
btn.tag = 100 + i; 
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;UITabBarController的属性&quot;&gt;&lt;a href=&quot;#UITabBarController的属性&quot; class=&quot;headerlink&quot; title=&quot;UITabBarController的属性&quot;&gt;&lt;/a&gt;UITabBarController的属性&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//选择的是哪个tab
self.selectedIndex = button.tag - 100;

//隐藏系统默认的样式
self.tabBar.hidden = YES;

//用数组管理视图控制器
self.viewControllers = tabArray;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Tab子视图调用根视图方法-UITabBarController&quot;&gt;&lt;a href=&quot;#Tab子视图调用根视图方法-UITabBarController&quot; class=&quot;headerlink&quot; title=&quot;Tab子视图调用根视图方法(UITabBarController)&quot;&gt;&lt;/a&gt;Tab子视图调用根视图方法(UITabBarController)&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;RootViewController *rootVC = (RootViewController *)self.tabBarController;
[rootVC showTabBar:NO];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;动画效果在于CGPoint-or-frame的改变&quot;&gt;&lt;a href=&quot;#动画效果在于CGPoint-or-frame的改变&quot; class=&quot;headerlink&quot; title=&quot;动画效果在于CGPoint or frame的改变&quot;&gt;&lt;/a&gt;动画效果在于CGPoint or frame的改变&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;[UIView animateWithDuration:0.2 animations:^{
    _selectView.center = button.center;
} completion:nil];


//重新赋值frame,让tabBar消失
[UIView animateWithDuration:0.2 animations:^{
    self.tabBarView.frame = frame;
} completion:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;UIButton的设置&quot;&gt;&lt;a href=&quot;#UIButton的设置&quot; class=&quot;headerlink&quot; title=&quot;UIButton的设置&quot;&gt;&lt;/a&gt;UIButton的设置&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//需要custom类型才能设置图片
UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];

//[pushButton setImage:(UIImage *) forState:(UIControlState)]
//标题和图片不能同时设置
[pushButton setTitle:@&amp;quot;Push&amp;quot; forState:UIControlStateNormal];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;视图顶部导航栏左右按钮&quot;&gt;&lt;a href=&quot;#视图顶部导航栏左右按钮&quot; class=&quot;headerlink&quot; title=&quot;视图顶部导航栏左右按钮&quot;&gt;&lt;/a&gt;视图顶部导航栏左右按钮&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//自定义导航栏按钮
- (void)initNavButton{

UIButton *writeBtn = [UIButton buttonWithType:UIButtonTypeCustom];
//导航按钮的xy值没有用
writeBtn.frame = CGRectMake(0, 0, writeButtonWidth, writeButtonHeight);
[writeBtn setBackgroundImage:[UIImage imageNamed:@&amp;quot;write&amp;quot;] forState:UIControlStateNormal];
[writeBtn addTarget:self action:@selector(presentAction) forControlEvents:UIControlEventTouchUpInside];
//添加自定义按钮
UIBarButtonItem *item = [[UIBarButtonItem alloc] initWithCustomView:writeBtn];
self.navigationItem.rightBarButtonItem = item;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;视图跳转-模态视图&quot;&gt;&lt;a href=&quot;#视图跳转-模态视图&quot; class=&quot;headerlink&quot; title=&quot;视图跳转 - 模态视图&quot;&gt;&lt;/a&gt;视图跳转 - 模态视图&lt;/h1&gt;&lt;h2 id=&quot;呈现使用present&quot;&gt;&lt;a href=&quot;#呈现使用present&quot; class=&quot;headerlink&quot; title=&quot;呈现使用present&quot;&gt;&lt;/a&gt;呈现使用present&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[self presentViewController:modalVC animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;退出使用dissmiss&quot;&gt;&lt;a href=&quot;#退出使用dissmiss&quot; class=&quot;headerlink&quot; title=&quot;退出使用dissmiss&quot;&gt;&lt;/a&gt;退出使用dissmiss&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)dismissAction{
[self dismissViewControllerAnimated:YES completion:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;视图跳转-push视图&quot;&gt;&lt;a href=&quot;#视图跳转-push视图&quot; class=&quot;headerlink&quot; title=&quot;视图跳转 - push视图&quot;&gt;&lt;/a&gt;视图跳转 - push视图&lt;/h1&gt;&lt;h2 id=&quot;呈现用导航视图push-show&quot;&gt;&lt;a href=&quot;#呈现用导航视图push-show&quot; class=&quot;headerlink&quot; title=&quot;呈现用导航视图push/show&quot;&gt;&lt;/a&gt;呈现用导航视图push/show&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)pushAction{
PushViewController *pushVC = [[PushViewController alloc] init];
[self.navigationController pushViewController:pushVC animated:YES];
//[self.navigationController showViewController:pushVC sender:nil];
RootViewController *rootVC = (RootViewController *)self.tabBarController;
[rootVC showTabBar:NO];
}    
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;退出用pop-的三种方式&quot;&gt;&lt;a href=&quot;#退出用pop-的三种方式&quot; class=&quot;headerlink&quot; title=&quot;退出用pop 的三种方式&quot;&gt;&lt;/a&gt;退出用pop 的三种方式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)popAction{

    // 回到上级视图
    [self.navigationController popViewControllerAnimated:YES];

    // 跳转到某视图
    //[self.navigationController popToViewController:&amp;lt;#(nonnull UIViewController *)#&amp;gt; animated:&amp;lt;#(BOOL)#&amp;gt;]

    // 跳转到根视图
    //[self.navigationController popToRootViewControllerAnimated:YES];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOSproj00901.png&quot; 
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="codeExample" scheme="http://jackliu17.github.io/tags/codeExample/"/>
    
  </entry>
  
  <entry>
    <title>设计复杂的iOS动画效果</title>
    <link href="http://jackliu17.github.io/2016/04/30/%E8%AE%BE%E8%AE%A1%E5%A4%8D%E6%9D%82%E7%9A%84iOS%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://jackliu17.github.io/2016/04/30/设计复杂的iOS动画效果/</id>
    <published>2016-04-30T08:56:02.000Z</published>
    <updated>2016-04-30T10:04:26.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;动画效果的UIView-Object&quot;&gt;&lt;a href=&quot;#动画效果的UIView-Object&quot; class=&quot;headerlink&quot; title=&quot;动画效果的UIView Object&quot;&gt;&lt;/a&gt;动画效果的UIView Object&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_animate_001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 显示动画
- (void)showWithDuration:(CGFloat)duration animated:(BOOL)animated;

// 隐藏动画
- (void)hideWithDuration:(CGFloat)duration animated:(BOOL)animated;

// 创建view
- (void)buildView;

// 动画百分比（手动设置动画的程度）
- (void)percent:(CGFloat)percent;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;制定统一的动画接口&quot;&gt;&lt;a href=&quot;#制定统一的动画接口&quot; class=&quot;headerlink&quot; title=&quot;制定统一的动画接口&quot;&gt;&lt;/a&gt;制定统一的动画接口&lt;/h1&gt;&lt;p&gt;即：相关有动画效果的类，有同一的动画方法命名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了实现后续复杂的动画组合&lt;/li&gt;
&lt;li&gt;后续的代码维护极为方便&lt;/li&gt;
&lt;li&gt;优先考虑里氏代换原则&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;动画中的高内聚低耦合原理&quot;&gt;&lt;a href=&quot;#动画中的高内聚低耦合原理&quot; class=&quot;headerlink&quot; title=&quot;动画中的高内聚低耦合原理&quot;&gt;&lt;/a&gt;动画中的高内聚低耦合原理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;高内聚：有动画效果的类，自身具有动画方法&lt;/li&gt;
&lt;li&gt;不要把实现动画的细节暴露在外&lt;/li&gt;
&lt;li&gt;设计动画类尽量要符合单一职能原则，以便后续方便组合成复杂的动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;设计动画函数的注意事项&quot;&gt;&lt;a href=&quot;#设计动画函数的注意事项&quot; class=&quot;headerlink&quot; title=&quot;设计动画函数的注意事项&quot;&gt;&lt;/a&gt;设计动画函数的注意事项&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;动画方法的命名统一&lt;/li&gt;
&lt;li&gt;预留非动画情形的设计（tableView等reuse情况）&lt;/li&gt;
&lt;li&gt;用百分比来表示动画的执行程度&lt;/li&gt;
&lt;li&gt;懒加载的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;动画效果就是frame值的重新设定&quot;&gt;&lt;a href=&quot;#动画效果就是frame值的重新设定&quot; class=&quot;headerlink&quot; title=&quot;动画效果就是frame值的重新设定&quot;&gt;&lt;/a&gt;动画效果就是frame值的重新设定&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;[UIView animateWithDuration:duration animations:^{
        self.frame = self.midRect;
        self.alpha = 1.f;
    }];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一个具有动画效果的类&quot;&gt;&lt;a href=&quot;#一个具有动画效果的类&quot; class=&quot;headerlink&quot; title=&quot;一个具有动画效果的类&quot;&gt;&lt;/a&gt;一个具有动画效果的类&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;LineView.h&amp;quot;

@interface LineView ()
@property (nonatomic) CGRect startRect;
@property (nonatomic) CGRect midRect;
@property (nonatomic) CGRect endRect;
@end

@implementation LineView

- (instancetype)initWithFrame:(CGRect)frame {
self = [super initWithFrame:frame];
if (self) {
    self.alpha = 0.f;
}
return self;
}

// 创建view
- (void)buildView {
// todo
self.startRect = self.frame;
self.midRect   = CGRectMake(self.startRect.origin.x + self.offsetX,
                            self.startRect.origin.y,
                            self.startRect.size.width,
                            self.startRect.size.height);
self.endRect   = CGRectMake(self.startRect.origin.x + self.offsetX * 2,
                            self.startRect.origin.y,
                            self.startRect.size.width,
                            self.startRect.size.height);
                        }


// 显示动画
- (void)showWithDuration:(CGFloat)duration animated:(BOOL)animated {
if (animated == YES) {
    [UIView animateWithDuration:duration animations:^{
        self.frame = self.midRect;
        self.alpha = 1.f;
    }];
} else {
    self.frame = self.midRect;
    self.alpha = 1.f;
}
}

// 隐藏动画
- (void)hideWithDuration:(CGFloat)duration animated:(BOOL)animated {
if (animated == YES) {
    [UIView animateWithDuration:duration animations:^{
        self.frame = self.endRect;
        self.alpha = 0.f;
    } completion:^(BOOL finished) {
        self.frame = self.startRect;
    }];
} else {
    self.frame = self.startRect;
    self.alpha = 0.f;
}
}



// 动画百分比（手动设置动画的程度）
- (void)percent:(CGFloat)percent {
CGFloat tmpOffsetX = 0;

if (percent &amp;lt;= 0) {
    tmpOffsetX = 0;
} else if (percent &amp;gt;= 1) {
    tmpOffsetX = self.offsetX;
} else {
    tmpOffsetX = percent * self.offsetX;
}

self.frame = CGRectMake(self.startRect.origin.x + tmpOffsetX,
                        self.startRect.origin.y,
                        self.startRect.size.width,
                        self.startRect.size.height);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;里氏代换原则处理动画类的继承问题&quot;&gt;&lt;a href=&quot;#里氏代换原则处理动画类的继承问题&quot; class=&quot;headerlink&quot; title=&quot;里氏代换原则处理动画类的继承问题&quot;&gt;&lt;/a&gt;里氏代换原则处理动画类的继承问题&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SourceView *tmpView = [[ChildTwoView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tmpView show];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;里氏代换原则的基本原理 (多态)&lt;/li&gt;
&lt;li&gt;设计中要确保父类可以直接调用子类的方法&lt;/li&gt;
&lt;li&gt;将父类设计成虚类&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;动画中的模块化设计&quot;&gt;&lt;a href=&quot;#动画中的模块化设计&quot; class=&quot;headerlink&quot; title=&quot;动画中的模块化设计&quot;&gt;&lt;/a&gt;动画中的模块化设计&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;动画效果实现难度的判断&lt;/li&gt;
&lt;li&gt;将看到的动画效果拆分成小模块&lt;/li&gt;
&lt;li&gt;将写好的小模块组合成你所需要的动画效果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ViewController.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

// 复杂的动画被写进了BaseAnimationView当中，没有暴露不必要的细节
BaseAnimationView *baseView = [[BaseAnimationView alloc] initWithFrame:CGRectZero];
[self.view addSubview:baseView];
[baseView show];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BaseAnimation.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)show {
[self.circleView show];
[self.lineView show];
}

- (void)hide {
[self.circleView hide];
[self.lineView hide];
}

- (void)buildView {
self.circleView = [[CircleView alloc] initWithFrame:CGRectZero];
[self addSubview:self.circleView];

self.lineView = [[RectView alloc] initWithFrame:CGRectZero];
[self addSubview:self.lineView];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;circleView.m / lineView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)show {}
- (void)hide {}
- (void)buildView {}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;延时执行某方法&quot;&gt;&lt;a href=&quot;#延时执行某方法&quot; class=&quot;headerlink&quot; title=&quot;延时执行某方法&quot;&gt;&lt;/a&gt;延时执行某方法&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;[self performSelector:@selector(excuteAfterDelay) withObject:nil afterDelay:6];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;初始化UIView&quot;&gt;&lt;a href=&quot;#初始化UIView&quot; class=&quot;headerlink&quot; title=&quot;初始化UIView&quot;&gt;&lt;/a&gt;初始化UIView&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame {
self = [super initWithFrame:frame];
if (self) {
    self.rect = frame;
}
return self;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动画效果的UIView-Object&quot;&gt;&lt;a href=&quot;#动画效果的UIView-Object&quot; class=&quot;headerlink&quot; title=&quot;动画效果的UIView Object&quot;&gt;&lt;/a&gt;动画效果的UIView Object&lt;/h1&gt;&lt;p&gt;&lt;img s
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="iOS_animation" scheme="http://jackliu17.github.io/tags/iOS-animation/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目8.QQ下拉菜单</title>
    <link href="http://jackliu17.github.io/2016/04/29/iOS%E9%A1%B9%E7%9B%AE8-QQ%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95/"/>
    <id>http://jackliu17.github.io/2016/04/29/iOS项目8-QQ下拉菜单/</id>
    <published>2016-04-29T12:56:05.000Z</published>
    <updated>2016-04-29T12:57:40.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_008_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;项目分析&quot;&gt;&lt;a href=&quot;#项目分析&quot; class=&quot;headerlink&quot; title=&quot;项目分析&quot;&gt;&lt;/a&gt;项目分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_008_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;h2 id=&quot;在项目里添加目录&quot;&gt;&lt;a href=&quot;#在项目里添加目录&quot; class=&quot;headerlink&quot; title=&quot;在项目里添加目录&quot;&gt;&lt;/a&gt;在项目里添加目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;点击左下角的+号 “Add file to ….”&lt;/li&gt;
&lt;li&gt;在弹出的对话框，选择左下角的”New folder”&lt;/li&gt;
&lt;li&gt;输入名称，点击右下角的”Add”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样添加的目录才会真实存在与项目中&lt;/p&gt;
&lt;h2 id=&quot;创建导航视图&quot;&gt;&lt;a href=&quot;#创建导航视图&quot; class=&quot;headerlink&quot; title=&quot;创建导航视图&quot;&gt;&lt;/a&gt;创建导航视图&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ListTableViewController *listVC = [[ListTableViewController alloc] init];
UINavigationController *navCtrl = [[UINavigationController alloc] initWithRootViewController:listVC];
self.window.rootViewController = navCtrl;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;加载数据&quot;&gt;&lt;a href=&quot;#加载数据&quot; class=&quot;headerlink&quot; title=&quot;加载数据&quot;&gt;&lt;/a&gt;加载数据&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;每个字典对应一个数据模型(Model class），plist中有多少个字典就有多少个Model class&lt;/li&gt;
&lt;li&gt;使用该方法加载数据 — [self setValuesForKeysWithDictionary:dict]&lt;/li&gt;
&lt;li&gt;plist的第一层级都是数组，所以懒加载返回的也是数组&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;表视图中设定Section-Header&quot;&gt;&lt;a href=&quot;#表视图中设定Section-Header&quot; class=&quot;headerlink&quot; title=&quot;表视图中设定Section Header&quot;&gt;&lt;/a&gt;表视图中设定Section Header&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;每次表视图变动需要reload&quot;&gt;&lt;a href=&quot;#每次表视图变动需要reload&quot; class=&quot;headerlink&quot; title=&quot;每次表视图变动需要reload&quot;&gt;&lt;/a&gt;每次表视图变动需要reload&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[self.tableView reloadData];
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;判断展开的Item数量&quot;&gt;&lt;a href=&quot;#判断展开的Item数量&quot; class=&quot;headerlink&quot; title=&quot;判断展开的Item数量&quot;&gt;&lt;/a&gt;判断展开的Item数量&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;NSInteger count = groupModel.isOpen ? groupModel.friends.count : 0;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;设置cell的代码&quot;&gt;&lt;a href=&quot;#设置cell的代码&quot; class=&quot;headerlink&quot; title=&quot;设置cell的代码&quot;&gt;&lt;/a&gt;设置cell的代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
static NSString *identifier = @&amp;quot;friendCell&amp;quot;;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
if (!cell) {
    cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:identifier];    
}
//对应的哪一个section
JKGroupModel *groupModel = self.dataArray[indexPath.section];
//对应的哪一个row
JKFriendsModel *friendModel = groupModel.friends[indexPath.row];
cell.imageView.image = [UIImage imageNamed:friendModel.icon];
cell.textLabel.text = friendModel.name;
cell.detailTextLabel.text = friendModel.intro;
return cell;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;初始化Headerview-UITableViewHeaderFooterView&quot;&gt;&lt;a href=&quot;#初始化Headerview-UITableViewHeaderFooterView&quot; class=&quot;headerlink&quot; title=&quot;初始化Headerview(UITableViewHeaderFooterView)&quot;&gt;&lt;/a&gt;初始化Headerview(UITableViewHeaderFooterView)&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//类似cell的创建

+ (instancetype)headerView:(UITableView *)tableView{

static NSString *identifier = @&amp;quot;header&amp;quot;;
HeaderView *header =(HeaderView *) [tableView dequeueReusableCellWithIdentifier:identifier];

//用以下这个方式，则只创建一次,此项目不采用
//HeaderView *header = [tableView dequeueReusableHeaderFooterViewWithIdentifier:identifier];

if (!header) {
    header = [[HeaderView alloc] initWithReuseIdentifier:identifier];
}
return header;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;布局子视图&quot;&gt;&lt;a href=&quot;#布局子视图&quot; class=&quot;headerlink&quot; title=&quot;布局子视图&quot;&gt;&lt;/a&gt;布局子视图&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (void)layoutSubviews{
[super layoutSubviews];
_arrowBtn.frame = self.bounds;
_label.frame = CGRectMake(self.frame.size.width - 70, 0, 60, self.frame.size.height);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;layoutSubviews方法，是当改变父控件高度的时候，自动调用这个方法，所以一般在这里面设置子控件的frame。因为子控件随着父控件而改变。&lt;/li&gt;
&lt;li&gt;UITableViewHeaderFooterView不可以用xib，只能用代码创建&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;UIButton的属性设置&quot;&gt;&lt;a href=&quot;#UIButton的属性设置&quot; class=&quot;headerlink&quot; title=&quot;UIButton的属性设置&quot;&gt;&lt;/a&gt;UIButton的属性设置&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//内容框的内边距
button.contentEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);

//内容的对齐
button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;

//标题的内边距
button.titleEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);

//为button设定方法
[button addTarget:self action:@selector(buttonAction) forControlEvents:UIControlEventTouchUpInside];
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;imageView-contentMode&quot;&gt;&lt;a href=&quot;#imageView-contentMode&quot; class=&quot;headerlink&quot; title=&quot;imageView.contentMode&quot;&gt;&lt;/a&gt;imageView.contentMode&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;button.imageView.contentMode = UIViewContentModeCenter;
button.imageView.clipsToBounds = NO;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个居中是包括了，横向和纵向都是居中。图片不会拉伸或者压缩，就是按照imageView的frame和图片的大小来居中显示的。&lt;/p&gt;
&lt;p&gt;这里有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图片比view的区域更大。这个时候会截取图片的中间部位显示在frame区域里面。&lt;/li&gt;
&lt;li&gt;图片比view的区域更小。这个时候图片会完整的显示在frame的中间位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在默认情况，图片的多出来的部分还是会显示屏幕上。如果不希望超过frame的区域显示在屏幕上要设置。clipsToBounds属性。&lt;/p&gt;
&lt;h2 id=&quot;每点击一次的BOOL值取反&quot;&gt;&lt;a href=&quot;#每点击一次的BOOL值取反&quot; class=&quot;headerlink&quot; title=&quot;每点击一次的BOOL值取反&quot;&gt;&lt;/a&gt;每点击一次的BOOL值取反&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;self.groupModel.isOpen = !self.groupModel.isOpen;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;调用代理方法&quot;&gt;&lt;a href=&quot;#调用代理方法&quot; class=&quot;headerlink&quot; title=&quot;调用代理方法&quot;&gt;&lt;/a&gt;调用代理方法&lt;/h2&gt;&lt;p&gt;代理就好比是自己有个武器不能用，然后让自己的小喽啰”id&lt;headerviewdelegate&gt; delegate” 交给他人来”viewController” 使用&lt;/headerviewdelegate&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ([self.delegate respondsToSelector:@selector(clickView)]) {
    [self.delegate clickView];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;小箭头的旋转&quot;&gt;&lt;a href=&quot;#小箭头的旋转&quot; class=&quot;headerlink&quot; title=&quot;小箭头的旋转&quot;&gt;&lt;/a&gt;小箭头的旋转&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//调用了tableView 的 reload方法,这个方法就会刷新headview,那样的话,就会重新生成一个headview
- (void)didMoveToSuperview{
_arrowBtn.imageView.transform = self.groupModel.isOpen ? CGAffineTransformMakeRotation(M_PI_2):CGAffineTransformMakeRotation(0);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/iOS_008_1.png&quot; alt
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="codeExample" scheme="http://jackliu17.github.io/tags/codeExample/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目7.超级猜图</title>
    <link href="http://jackliu17.github.io/2016/04/28/iOS%E9%A1%B9%E7%9B%AE7-%E8%B6%85%E7%BA%A7%E7%8C%9C%E5%9B%BE/"/>
    <id>http://jackliu17.github.io/2016/04/28/iOS项目7-超级猜图/</id>
    <published>2016-04-28T03:05:41.000Z</published>
    <updated>2016-05-11T09:05:10.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E8%B6%85%E7%BA%A7%E7%8C%9C%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;视图分析&quot;&gt;&lt;a href=&quot;#视图分析&quot; class=&quot;headerlink&quot; title=&quot;视图分析&quot;&gt;&lt;/a&gt;视图分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/guessImage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;加载plist数据&quot;&gt;&lt;a href=&quot;#加载plist数据&quot; class=&quot;headerlink&quot; title=&quot;加载plist数据&quot;&gt;&lt;/a&gt;加载plist数据&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;将数据的初始化放在了数据模型里&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JKQuestionInfo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (NSArray *)questions{

NSString *path = [[NSBundle mainBundle]pathForResource:@&amp;quot;questions&amp;quot; ofType:@&amp;quot;plist&amp;quot;];

NSArray *array = [NSArray arrayWithContentsOfFile:path];

NSMutableArray *arrayM = [NSMutableArray arrayWithCapacity:array.count];

for (NSDictionary *dict in array) {

    [arrayM addObject:[self questionWithDict:dict]];
}
return [arrayM copy];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ViewController&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)questions {
if (nil == _questions) {
    _questions = [JKQuestionInfo questions];
}
return _questions;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;ViewController&quot;&gt;&lt;a href=&quot;#ViewController&quot; class=&quot;headerlink&quot; title=&quot;ViewController&quot;&gt;&lt;/a&gt;ViewController&lt;/h1&gt;&lt;h2 id=&quot;定义常量&quot;&gt;&lt;a href=&quot;#定义常量&quot; class=&quot;headerlink&quot; title=&quot;定义常量&quot;&gt;&lt;/a&gt;定义常量&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//需要计算的话，用宏,否则用const,如下

//图片按钮的宽度
#define imgW self.imgInsideBtn.bounds.size.width

//答案按钮宽
CGFloat const kBtnW = 35;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;UIButton-配置&quot;&gt;&lt;a href=&quot;#UIButton-配置&quot; class=&quot;headerlink&quot; title=&quot;UIButton 配置&quot;&gt;&lt;/a&gt;UIButton 配置&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//为按钮设置背景图片
[self.imgInsideBtn setImage:question.image forState:UIControlStateNormal];

//设定按钮高亮下的背景图片
[btn setBackgroundImage:[UIImage imageNamed:@&amp;quot;btn_answer_highlighted&amp;quot;] forState:UIControlStateHighlighted];

//设定按钮常规下的字体颜色
[btn setTitleColor:kAnswerBtnTitleColor forState:UIControlStateNormal];

//设定按钮的点击方法
[btn addTarget:self action:@selector(answerBtnOnClick:) forControlEvents:UIControlEventTouchUpInside];

//设定按钮上的字符
[answerBtn setTitle:nil forState:UIControlStateNormal];

//alpha值切换按钮的不同状态
self.cover.alpha = 0.0;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;遍历移除所有子视图&quot;&gt;&lt;a href=&quot;#遍历移除所有子视图&quot; class=&quot;headerlink&quot; title=&quot;遍历移除所有子视图&quot;&gt;&lt;/a&gt;遍历移除所有子视图&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;for (UIButton *btn in self.answerView.subviews) {
    [btn removeFromSuperview];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;UIView-配置&quot;&gt;&lt;a href=&quot;#UIView-配置&quot; class=&quot;headerlink&quot; title=&quot;UIView 配置&quot;&gt;&lt;/a&gt;UIView 配置&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//该按钮不隐藏
optionBtn.hidden = NO;

//该view是否具有互动性
self.optionsView.userInteractionEnabled = YES;

//将中间图片按钮设置成是离屏幕最近一层,所有子视图的最上面
[self.view bringSubviewToFront:self.imgInsideBtn];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E8%B6%85%E7%B
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="codeExample" scheme="http://jackliu17.github.io/tags/codeExample/"/>
    
  </entry>
  
  <entry>
    <title>Android_Studio相关操作</title>
    <link href="http://jackliu17.github.io/2016/04/26/Android-Studio%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://jackliu17.github.io/2016/04/26/Android-Studio相关操作/</id>
    <published>2016-04-26T01:14:55.000Z</published>
    <updated>2016-04-26T01:23:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;创建assest-folder&quot;&gt;&lt;a href=&quot;#创建assest-folder&quot; class=&quot;headerlink&quot; title=&quot;创建assest folder&quot;&gt;&lt;/a&gt;创建assest folder&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/android_asset_foldrer.png&quot; alt=&quot;assest&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;导入jar文件&quot;&gt;&lt;a href=&quot;#导入jar文件&quot; class=&quot;headerlink&quot; title=&quot;导入jar文件&quot;&gt;&lt;/a&gt;导入jar文件&lt;/h2&gt;&lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/importjar1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot; class=&quot;headerlink&quot; title=&quot;2&quot;&gt;&lt;/a&gt;2&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/importjar2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot; class=&quot;headerlink&quot; title=&quot;3&quot;&gt;&lt;/a&gt;3&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/importjar3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;&lt;a href=&quot;#4&quot; class=&quot;headerlink&quot; title=&quot;4&quot;&gt;&lt;/a&gt;4&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/importjar4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;5&quot;&gt;&lt;a href=&quot;#5&quot; class=&quot;headerlink&quot; title=&quot;5&quot;&gt;&lt;/a&gt;5&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/importjar5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;6&quot;&gt;&lt;a href=&quot;#6&quot; class=&quot;headerlink&quot; title=&quot;6&quot;&gt;&lt;/a&gt;6&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/importjar6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建assest-folder&quot;&gt;&lt;a href=&quot;#创建assest-folder&quot; class=&quot;headerlink&quot; title=&quot;创建assest folder&quot;&gt;&lt;/a&gt;创建assest folder&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="Android" scheme="http://jackliu17.github.io/tags/Android/"/>
    
      <category term="Android_Studio" scheme="http://jackliu17.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>使用OpenGL_ES显示图像</title>
    <link href="http://jackliu17.github.io/2016/04/24/%E4%BD%BF%E7%94%A8OpenGL-ES%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/"/>
    <id>http://jackliu17.github.io/2016/04/24/使用OpenGL-ES显示图像/</id>
    <published>2016-04-24T06:58:54.000Z</published>
    <updated>2016-04-24T08:33:52.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/android-training-geek/opengl-index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;转载&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://developer.android.com/training/graphics/opengl/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android框架提供了大量的标准工具，用来创建吸引人的，功能丰富的图形界面。然而，如果我们希望应用在屏幕上所绘制的内容进行更多的控制，或者正在尝试建立三维图像，那么我们就需要一个不同的工具了。由Android框架提供的OpenGL ES接口给予我们一组可以显示高级动画和图形的工具集，它的功能仅仅受限于我们自身的想象力。同时，在许多Android设备上搭载的图形处理单元（GPU）都能为其提供GPU加速等性能优化。&lt;/p&gt;
&lt;p&gt;这系列课程将展示如何使用OpenGL构建应用的基础知识，包括配置，绘制对象，移动图形元素以及响应点击事件。&lt;/p&gt;
&lt;p&gt;这系列课程所涉及的样例代码使用的是OpenGL ES 2.0接口，这是当前Android设备所推荐的接口版本。关于更多OpenGL ES的版本信息，可以阅读：&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html#choosing-version&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenGL开发手册&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note：注意不要把OpenGL ES 1.x版本的接口和OpenGL ES 2.0的接口混合调用。这两种版本的接口不是通用的。如果尝试混用它们可能会让你感到无奈和沮丧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;建立OpenGL-ES的环境&quot;&gt;&lt;a href=&quot;#建立OpenGL-ES的环境&quot; class=&quot;headerlink&quot; title=&quot;建立OpenGL ES的环境&quot;&gt;&lt;/a&gt;建立OpenGL ES的环境&lt;/h1&gt;&lt;p&gt;要在应用中使用OpenGL ES绘制图像，我们必须为它们创建一个View容器。一种比较直接的方法是实现&lt;code&gt;GLSurfaceView&lt;/code&gt;类和&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;类。其中，&lt;code&gt;GLSurfaceView&lt;/code&gt;是一个View容器，它用来存放使用OpenGL绘制的图形，而&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;则用来控制在该View中绘制的内容。关于这两个类的更多信息，你可以阅读：&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenGL ES开发手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;GLSurfaceView&lt;/code&gt;是一种将OpenGL ES集成到应用中的方法之一。对于一个全屏的或者接近全屏的图形View，使用它是一个理想的选择。开发者如果希望把OpenGL ES的图形集成在布局的一小部分里面，那么可以考虑使用&lt;code&gt;TextureView&lt;/code&gt;。对于喜欢自己动手实现的开发者来说，还可以通过使用&lt;code&gt;SurfaceView&lt;/code&gt;搭建一个OpenGL ES View，但这将需要编写更多的代码。&lt;/p&gt;
&lt;p&gt;在这节课中，我们将展示如何在一个的&lt;code&gt;Activity&lt;/code&gt;中完成&lt;code&gt;GLSurfaceView&lt;/code&gt;和&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;的最简单的实现&lt;/p&gt;
&lt;h2 id=&quot;在Manifest配置文件中声明使用OpenGL-ES&quot;&gt;&lt;a href=&quot;#在Manifest配置文件中声明使用OpenGL-ES&quot; class=&quot;headerlink&quot; title=&quot;在Manifest配置文件中声明使用OpenGL ES&quot;&gt;&lt;/a&gt;在Manifest配置文件中声明使用OpenGL ES&lt;/h2&gt;&lt;p&gt;为了让应用能够使用OpenGL ES 2.0接口，我们必须将下列声明添加到Manifest配置文件当中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;uses-feature android:glEsVersion=&amp;quot;0x00020000&amp;quot; android:required=&amp;quot;true&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们的应用使用纹理压缩（Texture Compression），那么我们必须对支持的压缩格式也进行声明，确保应用仅安装在可以兼容的设备上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;supports-gl-texture android:name=&amp;quot;GL_OES_compressed_ETC1_RGB8_texture&amp;quot; /&amp;gt;
&amp;lt;supports-gl-texture android:name=&amp;quot;GL_OES_compressed_paletted_texture&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多关于纹理压缩的内容，可以阅读：&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html#textures&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenGL开发手册&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为OpenGL-ES图形创建一个activity&quot;&gt;&lt;a href=&quot;#为OpenGL-ES图形创建一个activity&quot; class=&quot;headerlink&quot; title=&quot;为OpenGL ES图形创建一个activity&quot;&gt;&lt;/a&gt;为OpenGL ES图形创建一个activity&lt;/h2&gt;&lt;p&gt;使用OpenGL ES的安卓应用就像其它类型的应用一样有自己的用户接口，即也拥有多个Activity。主要的区别体现在Acitivity布局内容上的差异。在许多应用中你可能会使用&lt;code&gt;TextView&lt;/code&gt;，&lt;code&gt;Button&lt;/code&gt;和&lt;code&gt;ListView&lt;/code&gt;等，而在使用OpenGL ES的应用中，我们还可以添加一个&lt;code&gt;GLSurfaceView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面的代码展示了一个使用&lt;code&gt;GLSurfaceView&lt;/code&gt;作为其主View的Activity：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class OpenGLES20Activity extends Activity {

private GLSurfaceView mGLView;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Create a GLSurfaceView instance and set it
    // as the ContentView for this Activity.
    mGLView = new MyGLSurfaceView(this);
    setContentView(mGLView);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Note：OpenGL ES 2.0需要Android 2.2（API Level 8）或更高版本的系统，所以确保你的Android项目的API版本满足该要求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构建一个GLSurfaceView对象&quot;&gt;&lt;a href=&quot;#构建一个GLSurfaceView对象&quot; class=&quot;headerlink&quot; title=&quot;构建一个GLSurfaceView对象&quot;&gt;&lt;/a&gt;构建一个GLSurfaceView对象&lt;/h2&gt;&lt;p&gt;&lt;code&gt;GLSurfaceView&lt;/code&gt;是一种比较特殊的View，我们可以在该View中绘制OpenGL ES图形，不过它自己并不做太多和绘制图形相关的任务。绘制对象的任务是由你在该View中配置的&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;所控制的。事实上，这个对象的代码非常简短，你可能会希望不要继承它，直接创建一个未经修改的&lt;code&gt;GLSurfaceView&lt;/code&gt;实例，不过请不要这么做，因为我们需要继承该类来捕捉触控事件，这方面知识会在响应触摸事件（该系列课程的最后一节课）中做进一步的介绍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GLSurfaceView&lt;/code&gt;的核心代码非常简短，所以对于一个快速的实现而言，我们通常可以在Acitvity中创建一个内部类并使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyGLSurfaceView extends GLSurfaceView {

private final MyGLRenderer mRenderer;

public MyGLSurfaceView(Context context){
    super(context);

    // Create an OpenGL ES 2.0 context
    setEGLContextClientVersion(2);

    mRenderer = new MyGLRenderer();

    // Set the Renderer for drawing on the GLSurfaceView
    setRenderer(mRenderer);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个对于&lt;code&gt;GLSurfaceView&lt;/code&gt;实现的可选选项，是将渲染模式设置为：&lt;code&gt;GLSurfaceView.RENDERMODE_WHEN_DIRTY&lt;/code&gt;，其含义是：仅在你的绘制数据发生变化时才在视图中进行绘制操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Render the view only when there is a change in the drawing data
setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果选用这一配置选项，那么除非调用了&lt;code&gt;requestRender()&lt;/code&gt;，否则&lt;code&gt;GLSurfaceView&lt;/code&gt;不会被重新绘制，这样做可以让应用的性能及效率得到提高。&lt;/p&gt;
&lt;h2 id=&quot;构建一个渲染类&quot;&gt;&lt;a href=&quot;#构建一个渲染类&quot; class=&quot;headerlink&quot; title=&quot;构建一个渲染类&quot;&gt;&lt;/a&gt;构建一个渲染类&lt;/h2&gt;&lt;p&gt;在一个使用OpenGL ES的应用中，一个&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;类的实现（或者我们将其称之为渲染器），正是事情变得有趣的地方。该类会控制和其相关联的&lt;code&gt;GLSurfaceView&lt;/code&gt;，具体而言，它会控制在&lt;code&gt;GLSurfaceView&lt;/code&gt;上绘制的内容。在渲染器中，一共有三个方法会被Android系统调用，以此来明确要在&lt;code&gt;GLSurfaceView&lt;/code&gt;上绘制的内容以及如何绘制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;onSurfaceCreated()&lt;/code&gt;：调用一次，用来配置View的OpenGL ES环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDrawFrame()&lt;/code&gt;：每次重新绘制View时被调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onSurfaceChanged()&lt;/code&gt;：如果View的几何形态发生变化时会被调用，例如当设备的屏幕方向发生改变时。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个非常基本的OpenGL ES渲染器的实现，它仅仅在&lt;code&gt;GLSurfaceView&lt;/code&gt;中画一个黑色的背景：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyGLRenderer implements GLSurfaceView.Renderer {

public void onSurfaceCreated(GL10 unused, EGLConfig config) {
    // Set the background frame color
    GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
}

public void onDrawFrame(GL10 unused) {
    // Redraw background color
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
}

public void onSurfaceChanged(GL10 unused, int width, int height) {
    GLES20.glViewport(0, 0, width, height);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是这样！上面的代码创建了一个简单地应用程序，它使用OpenGL让屏幕呈现为黑色。虽然它的代码看上去并没有做什么非常有意思的事情，但是通过创建这些类，我们已经对使用OpenGL绘制图形有了基本的认识和铺垫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note：你可能想知道，自己明明使用的是OpenGL ES 2.0接口，为什么这些方法会有一个GL10的参数。这是因为这些方法的签名（Method Signature）在2.0接口中被简&amp;gt;单地重用了，以此来保持Android框架的代码尽量简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你对OpenGL ES接口很熟悉，那么你现在就可以在你的应用中构建一个OpenGL ES的环境并绘制图形了。当然， 如果你希望获取更多的帮助来学会使用OpenGL，那么请继续学习下一节课程获取更多的知识。&lt;/p&gt;
&lt;h1 id=&quot;定义形状&quot;&gt;&lt;a href=&quot;#定义形状&quot; class=&quot;headerlink&quot; title=&quot;定义形状&quot;&gt;&lt;/a&gt;定义形状&lt;/h1&gt;&lt;p&gt;在一个OpenGL ES View的上下文（Context）中定义形状，是创建你的杰作所需要的第一步。在了解关于OpenGL ES如何定义图形对象的基本知识之前，通过OpenGL ES 绘图可能会有些困难。&lt;/p&gt;
&lt;p&gt;这节课将讲解OpenGL ES相对于Android设备屏幕的坐标系，定义形状和形状表面的基本知识，如定义一个三角形和一个矩形。&lt;/p&gt;
&lt;h2 id=&quot;定义一个三角形&quot;&gt;&lt;a href=&quot;#定义一个三角形&quot; class=&quot;headerlink&quot; title=&quot;定义一个三角形&quot;&gt;&lt;/a&gt;定义一个三角形&lt;/h2&gt;&lt;p&gt;OpenGL ES允许我们使用三维空间的坐标来定义绘画对象。所以在我们能画三角形之前，必须先定义它的坐标。在OpenGL 中，典型的办法是为坐标定义一个浮点型的顶点数组。为了高效起见，我们可以将坐标写入一个&lt;code&gt;ByteBuffer&lt;/code&gt;，它将会传入OpenGl ES的图形处理流程中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Triangle {

private FloatBuffer vertexBuffer;

// number of coordinates per vertex in this array
static final int COORDS_PER_VERTEX = 3;
static float triangleCoords[] = {   // in counterclockwise order:
         0.0f,  0.622008459f, 0.0f, // top
        -0.5f, -0.311004243f, 0.0f, // bottom left
         0.5f, -0.311004243f, 0.0f  // bottom right
};

// Set color with red, green, blue and alpha (opacity) values
float color[] = { 0.63671875f, 0.76953125f, 0.22265625f, 1.0f };

public Triangle() {
    // initialize vertex byte buffer for shape coordinates
    ByteBuffer bb = ByteBuffer.allocateDirect(
            // (number of coordinate values * 4 bytes per float)
            triangleCoords.length * 4);
    // use the device hardware&amp;apos;s native byte order
    bb.order(ByteOrder.nativeOrder());

    // create a floating point buffer from the ByteBuffer
    vertexBuffer = bb.asFloatBuffer();
    // add the coordinates to the FloatBuffer
    vertexBuffer.put(triangleCoords);
    // set the buffer to read the first coordinate
    vertexBuffer.position(0);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认情况下，OpenGL ES会假定一个坐标系，在这个坐标系中，[0, 0, 0]（分别对应X轴坐标, Y轴坐标, Z轴坐标）对应的是GLSurfaceView的中心。[1, 1, 0]对应的是右上角，[-1, -1, 0]对应的则是左下角。如果想要看此坐标系的插图说明，可以阅读&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html#faces-winding&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenGL ES开发手册&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;定义一个矩形&quot;&gt;&lt;a href=&quot;#定义一个矩形&quot; class=&quot;headerlink&quot; title=&quot;定义一个矩形&quot;&gt;&lt;/a&gt;定义一个矩形&lt;/h2&gt;&lt;p&gt;在OpenGL中定义三角形非常简单，那么你是否想要来点更复杂的呢？比如，定义一个矩形？有很多方法可以用来定义矩形，不过在OpenGL ES中最典型的办法是使用两个三角形拼接在一起：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/openGL.png&quot; alt=&quot;定义一个矩形&quot;&gt;&lt;/p&gt;
&lt;p&gt;再一次地，我们需要逆时针地为三角形顶点定义坐标来表现这个图形，并将值放入一个&lt;code&gt;ByteBuffer&lt;/code&gt;中。为了避免由两个三角形重合的那条边的顶点被重复定义，可以使用一个绘制列表来告诉OpenGL ES图形处理流程应该如何画这些顶点。下面是代码样例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Square {

private FloatBuffer vertexBuffer;
private ShortBuffer drawListBuffer;

// number of coordinates per vertex in this array
static final int COORDS_PER_VERTEX = 3;
static float squareCoords[] = {
        -0.5f,  0.5f, 0.0f,   // top left
        -0.5f, -0.5f, 0.0f,   // bottom left
         0.5f, -0.5f, 0.0f,   // bottom right
         0.5f,  0.5f, 0.0f }; // top right

private short drawOrder[] = { 0, 1, 2, 0, 2, 3 }; // order to draw vertices

public Square() {
    // initialize vertex byte buffer for shape coordinates
    ByteBuffer bb = ByteBuffer.allocateDirect(
    // (# of coordinate values * 4 bytes per float)
            squareCoords.length * 4);
    bb.order(ByteOrder.nativeOrder());
    vertexBuffer = bb.asFloatBuffer();
    vertexBuffer.put(squareCoords);
    vertexBuffer.position(0);

    // initialize byte buffer for the draw list
    ByteBuffer dlb = ByteBuffer.allocateDirect(
    // (# of coordinate values * 2 bytes per short)
            drawOrder.length * 2);
    dlb.order(ByteOrder.nativeOrder());
    drawListBuffer = dlb.asShortBuffer();
    drawListBuffer.put(drawOrder);
    drawListBuffer.position(0);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该样例可以看作是一个如何使用OpenGL创建复杂图形的启发，通常来说，我们需要使用三角形的集合来绘制对象。在下一节课中，我们将学习如何在屏幕上画这些形状&lt;/p&gt;
&lt;h1 id=&quot;绘制形状&quot;&gt;&lt;a href=&quot;#绘制形状&quot; class=&quot;headerlink&quot; title=&quot;绘制形状&quot;&gt;&lt;/a&gt;绘制形状&lt;/h1&gt;&lt;p&gt;在定义了使用OpenGL绘制的形状之后，你可能希望绘制出它们。使用OpenGL ES 2.0绘制图形可能会比你想象当中更复杂一些，因为API中提供了大量对于图形渲染流程的控制。&lt;/p&gt;
&lt;p&gt;这节课将解释如何使用OpenGL ES 2.0接口画出在上一节课中定义的形状。&lt;/p&gt;
&lt;h2 id=&quot;初始化形状&quot;&gt;&lt;a href=&quot;#初始化形状&quot; class=&quot;headerlink&quot; title=&quot;初始化形状&quot;&gt;&lt;/a&gt;初始化形状&lt;/h2&gt;&lt;p&gt;在你开始绘画之前，你需要初始化并加载你期望绘制的图形。除非你所使用的形状结构（原始坐标）在执行过程中发生了变化，不然的话你应该在渲染器的onSurfaceCreated()方法中初始化它们，这样做是出于内存和执行效率的考量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyGLRenderer implements GLSurfaceView.Renderer {

...
private Triangle mTriangle;
private Square   mSquare;

public void onSurfaceCreated(GL10 unused, EGLConfig config) {
    ...

    // initialize a triangle
    mTriangle = new Triangle();
    // initialize a square
    mSquare = new Square();
}
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;画一个形状&quot;&gt;&lt;a href=&quot;#画一个形状&quot; class=&quot;headerlink&quot; title=&quot;画一个形状&quot;&gt;&lt;/a&gt;画一个形状&lt;/h2&gt;&lt;p&gt;使用OpenGL ES 2.0画一个定义好的形状需要较多代码，因为你需要提供很多图形渲染流程的细节。具体而言，你必须定义如下几项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顶点着色器（Vertex Shader）：用来渲染形状顶点的OpenGL ES代码。&lt;/li&gt;
&lt;li&gt;片段着色器（Fragment Shader）：使用颜色或纹理渲染形状表面的OpenGL ES代码。&lt;/li&gt;
&lt;li&gt;程式（Program）：一个OpenGL ES对象，包含了你希望用来绘制一个或更多图形所要用到的着色器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你需要至少一个顶点着色器来绘制一个形状，以及一个片段着色器为该形状上色。这些着色器必须被编译然后添加到一个OpenGL ES Program当中，并利用它来绘制形状。下面的代码在Triangle类中定义了基本的着色器，我们可以利用它们绘制出一个图形：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Triangle {

private final String vertexShaderCode =
    &amp;quot;attribute vec4 vPosition;&amp;quot; +
    &amp;quot;void main() {&amp;quot; +
    &amp;quot;  gl_Position = vPosition;&amp;quot; +
    &amp;quot;}&amp;quot;;

private final String fragmentShaderCode =
    &amp;quot;precision mediump float;&amp;quot; +
    &amp;quot;uniform vec4 vColor;&amp;quot; +
    &amp;quot;void main() {&amp;quot; +
    &amp;quot;  gl_FragColor = vColor;&amp;quot; +
    &amp;quot;}&amp;quot;;

...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;着色器包含了OpenGL Shading Language（GLSL）代码，它必须先被编译然后才能在OpenGL环境中使用。要编译这些代码，需要在你的渲染器类中创建一个辅助方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static int loadShader(int type, String shaderCode){

// create a vertex shader type (GLES20.GL_VERTEX_SHADER)
// or a fragment shader type (GLES20.GL_FRAGMENT_SHADER)
int shader = GLES20.glCreateShader(type);

// add the source code to the shader and compile it
GLES20.glShaderSource(shader, shaderCode);
GLES20.glCompileShader(shader);

return shader;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了绘制你的图形，你必须编译着色器代码，将它们添加至一个OpenGL ES Program对象中，然后执行链接。在你的绘制对象的构造函数里做这些事情，这样上述步骤就只用执行一次&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note：编译OpenGL ES着色器及链接操作对于CPU周期和处理时间而言，消耗是巨大的，所以你应该避免重复执行这些事情。如果在执行期间不知道着色器的内容，那么你应该在构建你的应用时，确保它们只被创建了一次，并且缓存以备后续使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public class Triangle() {
...

private final int mProgram;

public Triangle() {
    ...

    int vertexShader = MyGLRenderer.loadShader(GLES20.GL_VERTEX_SHADER,
                                    vertexShaderCode);
    int fragmentShader = MyGLRenderer.loadShader(GLES20.GL_FRAGMENT_SHADER,
                                    fragmentShaderCode);

    // create empty OpenGL ES Program
    mProgram = GLES20.glCreateProgram();

    // add the vertex shader to program
    GLES20.glAttachShader(mProgram, vertexShader);

    // add the fragment shader to program
    GLES20.glAttachShader(mProgram, fragmentShader);

    // creates OpenGL ES program executables
    GLES20.glLinkProgram(mProgram);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，你已经完全准备好添加实际的调用语句来绘制你的图形了。使用OpenGL ES绘制图形需要你定义一些变量来告诉渲染流程你需要绘制的内容以及如何绘制。既然绘制属性会根据形状的不同而发生变化，把绘制逻辑包含在形状类里面将是一个不错的主意。&lt;/p&gt;
&lt;p&gt;创建一个&lt;code&gt;draw()&lt;/code&gt;方法来绘制图形。下面的代码为形状的顶点着色器和形状着色器设置了位置和颜色值，然后执行绘制函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private int mPositionHandle;
private int mColorHandle;

private final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX;
private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex

public void draw() {
// Add program to OpenGL ES environment
GLES20.glUseProgram(mProgram);

// get handle to vertex shader&amp;apos;s vPosition member
mPositionHandle = GLES20.glGetAttribLocation(mProgram, &amp;quot;vPosition&amp;quot;);

// Enable a handle to the triangle vertices
GLES20.glEnableVertexAttribArray(mPositionHandle);

// Prepare the triangle coordinate data
GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX,
                             GLES20.GL_FLOAT, false,
                             vertexStride, vertexBuffer);

// get handle to fragment shader&amp;apos;s vColor member
mColorHandle = GLES20.glGetUniformLocation(mProgram, &amp;quot;vColor&amp;quot;);

// Set color for drawing the triangle
GLES20.glUniform4fv(mColorHandle, 1, color, 0);

// Draw the triangle
GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

// Disable vertex array
GLES20.glDisableVertexAttribArray(mPositionHandle);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦你完成了上述所有代码，仅需要在你渲染器的&lt;code&gt;onDrawFrame()&lt;/code&gt;方法中调用&lt;code&gt;draw()&lt;/code&gt;方法就可以画出我们想要画的对象了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onDrawFrame(GL10 unused) {
...

mTriangle.draw();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你运行这个应用时，它看上去会像是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/openGL2.png&quot; alt=&quot;openGL2&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这个代码样例中，还存在一些问题。首先，它无法给用户带来什么深刻的印象。其次，这个三角形看上去有一些扁，另外当你改变屏幕方向时，它的形状也会随之改变。发生形变的原因是因为对象的顶点没有根据显示&lt;code&gt;GLSurfaceView&lt;/code&gt;的屏幕区域的长宽比进行修正。你可以在下一节课中使用投影（Projection）或者相机视角（Camera View）来解决这个问题。&lt;/p&gt;
&lt;p&gt;最后，这个三角形是静止的，这看上去有些无聊。在添加移动课程当中（后续课程），你会让这个形状发生旋转，并使用一些OpenGL ES图形处理流程中更加新奇的用法。&lt;/p&gt;
&lt;h1 id=&quot;运用投影与相机视角&quot;&gt;&lt;a href=&quot;#运用投影与相机视角&quot; class=&quot;headerlink&quot; title=&quot;运用投影与相机视角&quot;&gt;&lt;/a&gt;运用投影与相机视角&lt;/h1&gt;&lt;p&gt;在OpenGL ES环境中，利用投影和相机视角可以让显示的绘图对象更加酷似于我们用肉眼看到的真实物体。该物理视角的仿真是对绘制对象坐标的进行数学变换实现的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;投影（Projection）：这个变换会基于显示它们的&lt;code&gt;GLSurfaceView&lt;/code&gt;的长和宽，来调整绘图对象的坐标。如果没有该计算，那么用OpenGL ES绘制的对象会由于其长宽比例和View窗口比例的不一致而发生形变。一个投影变换一般仅当OpenGL View的比例在渲染器的&lt;code&gt;onSurfaceChanged()&lt;/code&gt;方法中建立或发生变化时才被计算。关于更多OpenGL ES投影和坐标映射的知识，可以阅读&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html#coordinate-mapping&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mapping Coordinates for Drawn Objects&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;相机视角（Camera View）：这个变换会基于一个虚拟相机位置改变绘图对象的坐标。注意到OpenGL ES并没有定义一个实际的相机对象，取而代之的，它提供了一些辅助方法，通过对绘图对象的变换来模拟相机视角。一个相机视角变换可能仅在建立你的&lt;code&gt;GLSurfaceView&lt;/code&gt;时计算一次，也可能根据用户的行为或者你的应用的功能进行动态调整。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这节课将解释如何创建一个投影和一个相机视角，并应用它们到&lt;code&gt;GLSurfaceView&lt;/code&gt;中的绘制图像上。&lt;/p&gt;
&lt;h2 id=&quot;定义一个投影&quot;&gt;&lt;a href=&quot;#定义一个投影&quot; class=&quot;headerlink&quot; title=&quot;定义一个投影&quot;&gt;&lt;/a&gt;定义一个投影&lt;/h2&gt;&lt;p&gt;投影变换的数据会在&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;类的&lt;code&gt;onSurfaceChanged()&lt;/code&gt;方法中被计算。下面的代码首先接收&lt;code&gt;GLSurfaceView&lt;/code&gt;的高和宽，然后利用它并使用&lt;code&gt;Matrix.frustumM()&lt;/code&gt;方法来填充一个投影变换矩阵（Projection Transformation Matrix）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// mMVPMatrix is an abbreviation for &amp;quot;Model View Projection Matrix&amp;quot;
private final float[] mMVPMatrix = new float[16];
private final float[] mProjectionMatrix = new float[16];
private final float[] mViewMatrix = new float[16];

@Override
public void onSurfaceChanged(GL10 unused, int width, int height) {
GLES20.glViewport(0, 0, width, height);

float ratio = (float) width / height;

// this projection matrix is applied to object coordinates
// in the onDrawFrame() method
Matrix.frustumM(mProjectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该代码填充了一个投影矩阵：&lt;code&gt;mProjectionMatrix&lt;/code&gt;，在下一节中，我们可以在&lt;code&gt;onDrawFrame()&lt;/code&gt;方法中将它和一个相机视角变换结合起来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note：在绘图对象上只应用一个投影变换会导致显示效果看上去很空旷。一般而言，我们还要实现一个相机视角，使得所有对象出现在屏幕上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义一个相机视角&quot;&gt;&lt;a href=&quot;#定义一个相机视角&quot; class=&quot;headerlink&quot; title=&quot;定义一个相机视角&quot;&gt;&lt;/a&gt;定义一个相机视角&lt;/h2&gt;&lt;p&gt;在渲染器中添加一个相机视角变换作为绘图过程的一部分，以此完成我们的绘图对象所需变换的所有步骤。在下面的代码中，使用&lt;code&gt;Matrix.setLookAtM()&lt;/code&gt;方法来计算相机视角变换，然后与之前计算的投影矩阵结合起来，结合后的变换矩阵传递给绘制图像：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onDrawFrame(GL10 unused) {
...
// Set the camera position (View matrix)
Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);

// Calculate the projection and view transformation
Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);

// Draw shape
mTriangle.draw(mMVPMatrix);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;应用投影和相机变换&quot;&gt;&lt;a href=&quot;#应用投影和相机变换&quot; class=&quot;headerlink&quot; title=&quot;应用投影和相机变换&quot;&gt;&lt;/a&gt;应用投影和相机变换&lt;/h2&gt;&lt;p&gt;为了使用在之前章节中结合了的相机视角变换和投影变换，我们首先为之前在Triangle类中定义的顶点着色器添加一个Matrix变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Triangle {

private final String vertexShaderCode =
    // This matrix member variable provides a hook to manipulate
    // the coordinates of the objects that use this vertex shader
    &amp;quot;uniform mat4 uMVPMatrix;&amp;quot; +
    &amp;quot;attribute vec4 vPosition;&amp;quot; +
    &amp;quot;void main() {&amp;quot; +
    // the matrix must be included as a modifier of gl_Position
    // Note that the uMVPMatrix factor *must be first* in order
    // for the matrix multiplication product to be correct.
    &amp;quot;  gl_Position = uMVPMatrix * vPosition;&amp;quot; +
    &amp;quot;}&amp;quot;;

// Use to access and set the view transformation
private int mMVPMatrixHandle;

...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，修改图形对象的&lt;code&gt;draw()&lt;/code&gt;方法，使得它接收组合后的变换矩阵，并将它应用到图形上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void draw(float[] mvpMatrix) { // pass in the calculated transformation matrix
...

// get handle to shape&amp;apos;s transformation matrix
mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, &amp;quot;uMVPMatrix&amp;quot;);

// Pass the projection and view transformation to the shader
GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);

// Draw the triangle
GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);

// Disable vertex array
GLES20.glDisableVertexAttribArray(mPositionHandle);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦我们正确地计算并应用了投影变换和相机视角变换，我们的图形就会以正确的比例绘制出来，它看上去会像是这样:&lt;br&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/OpenGL3.png&quot; alt=&quot;OPENGL3&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在，应用已经可以通过正确的比例显示图形了，下面就为图形添加一些动画效果吧！&lt;/p&gt;
&lt;h1 id=&quot;添加移动&quot;&gt;&lt;a href=&quot;#添加移动&quot; class=&quot;headerlink&quot; title=&quot;添加移动&quot;&gt;&lt;/a&gt;添加移动&lt;/h1&gt;&lt;p&gt;在屏幕上绘制图形是OpenGL的一个基本特性，当然我们也可以通过其它的Android图形框架类做这些事情，包括&lt;code&gt;Canvas&lt;/code&gt;和&lt;code&gt;Drawable&lt;/code&gt;对象。OpenGL ES的特别之处在于，它还提供了其它的一些功能，比如在三维空间中对绘制图形进行移动和变换操作，或者通过其它独有的方法创建出引人入胜的用户体验。&lt;/p&gt;
&lt;p&gt;在这节课中，我们会更深入地学习OpenGL ES的知识：对一个图形添加旋转动画。&lt;/p&gt;
&lt;h2 id=&quot;旋转一个形状&quot;&gt;&lt;a href=&quot;#旋转一个形状&quot; class=&quot;headerlink&quot; title=&quot;旋转一个形状&quot;&gt;&lt;/a&gt;旋转一个形状&lt;/h2&gt;&lt;p&gt;使用OpenGL ES 2.0 旋转一个绘制图形是比较简单的。在渲染器中，创建另一个变换矩阵（一个旋转矩阵），并且将它和我们的投影变换矩阵以及相机视角变换矩阵结合在一起：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private float[] mRotationMatrix = new float[16];
public void onDrawFrame(GL10 gl) {
float[] scratch = new float[16];

...

// Create a rotation transformation for the triangle
long time = SystemClock.uptimeMillis() % 4000L;
float angle = 0.090f * ((int) time);
Matrix.setRotateM(mRotationMatrix, 0, angle, 0, 0, -1.0f);

// Combine the rotation matrix with the projection and camera view
// Note that the mMVPMatrix factor *must be first* in order
// for the matrix multiplication product to be correct.
Matrix.multiplyMM(scratch, 0, mMVPMatrix, 0, mRotationMatrix, 0);

// Draw triangle
mTriangle.draw(scratch);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果完成了这些变更以后，你的三角形还是没有旋转的话，确认一下你是否将启用&lt;code&gt;GLSurfaceView.RENDERMODE_WHEN_DIRTY&lt;/code&gt;的这一配置所对应的代码注释掉了，有关该方面的知识会在下一节中展开。&lt;/p&gt;
&lt;h2 id=&quot;启用连续渲染&quot;&gt;&lt;a href=&quot;#启用连续渲染&quot; class=&quot;headerlink&quot; title=&quot;启用连续渲染&quot;&gt;&lt;/a&gt;启用连续渲染&lt;/h2&gt;&lt;p&gt;如果严格按照这节课的样例代码走到了现在这一步，那么请确认一下是否将设置渲染模式为&lt;code&gt;RENDERMODE_WHEN_DIRTY&lt;/code&gt;的那行代码注释了，不然的话OpenGL只会对这个形状执行一次旋转，然后就等待&lt;code&gt;GLSurfaceView&lt;/code&gt;容器的&lt;code&gt;requestRender()&lt;/code&gt;方法被调用后才会继续执行渲染操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public MyGLSurfaceView(Context context) {
...
// Render the view only when there is a change in the drawing data.
// To allow the triangle to rotate automatically, this line is commented out:
//setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除非某个对象，它的变化和用户的交互无关，不然的话一般还是建议将这个配置打开。在下一节课中的内容将会把这个注释放开，再次设定这一配置选项。&lt;/p&gt;
&lt;h1 id=&quot;响应触摸事件&quot;&gt;&lt;a href=&quot;#响应触摸事件&quot; class=&quot;headerlink&quot; title=&quot;响应触摸事件&quot;&gt;&lt;/a&gt;响应触摸事件&lt;/h1&gt;&lt;p&gt;让对象根据预设的程序运动（如让一个三角形旋转），可以有效地引起用户的注意，但是如果希望让OpenGL ES的图形对象与用户交互呢？让我们的OpenGL ES应用可以支持触控交互的关键点在于，拓展&lt;code&gt;GLSurfaceView&lt;/code&gt;的实现，重写&lt;code&gt;onTouchEvent()&lt;/code&gt;方法来监听触摸事件。&lt;/p&gt;
&lt;p&gt;这节课将会向你展示如何监听触控事件，让用户旋转一个OpenGL ES对象。&lt;/p&gt;
&lt;h2 id=&quot;配置触摸监听器&quot;&gt;&lt;a href=&quot;#配置触摸监听器&quot; class=&quot;headerlink&quot; title=&quot;配置触摸监听器&quot;&gt;&lt;/a&gt;配置触摸监听器&lt;/h2&gt;&lt;p&gt;为了让我们的OpenGL ES应用响应触控事件，我们必须实现&lt;code&gt;GLSurfaceView&lt;/code&gt;类中的&lt;code&gt;onTouchEvent()&lt;/code&gt;方法。下面的例子展示了如何监听&lt;code&gt;MotionEvent.ACTION_MOVE&lt;/code&gt;事件，并将事件转换为形状旋转的角度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final float TOUCH_SCALE_FACTOR = 180.0f / 320;
private float mPreviousX;
private float mPreviousY;

@Override
public boolean onTouchEvent(MotionEvent e) {
// MotionEvent reports input details from the touch screen
// and other input controls. In this case, you are only
// interested in events where the touch position changed.

float x = e.getX();
float y = e.getY();

switch (e.getAction()) {
    case MotionEvent.ACTION_MOVE:

        float dx = x - mPreviousX;
        float dy = y - mPreviousY;

        // reverse direction of rotation above the mid-line
        if (y &amp;gt; getHeight() / 2) {
          dx = dx * -1 ;
        }

        // reverse direction of rotation to left of the mid-line
        if (x &amp;lt; getWidth() / 2) {
          dy = dy * -1 ;
        }

        mRenderer.setAngle(
                mRenderer.getAngle() +
                ((dx + dy) * TOUCH_SCALE_FACTOR));
        requestRender();
}
mPreviousX = x;
mPreviousY = y;
return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意在计算旋转角度后，该方法会调用&lt;code&gt;requestRender()&lt;/code&gt;来告诉渲染器现在可以进行渲染了。这种办法对于这个例子来说是最有效的，因为图形并不需要重新绘制，除非有一个旋转角度的变化。当然，为了能够真正实现执行效率的提高，记得使用&lt;code&gt;setRenderMode()&lt;/code&gt;方法以保证渲染器仅在数据发生变化时才会重新绘制图形，所以请确保这一行代码没有被注释掉：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public MyGLSurfaceView(Context context) {
...
// Render the view only when there is a change in the drawing data
setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;公开旋转角度&quot;&gt;&lt;a href=&quot;#公开旋转角度&quot; class=&quot;headerlink&quot; title=&quot;公开旋转角度&quot;&gt;&lt;/a&gt;公开旋转角度&lt;/h2&gt;&lt;p&gt;上述样例代码需要我们公开旋转的角度，具体来说，是在渲染器中添加一个&lt;code&gt;public&lt;/code&gt;成员变量。由于渲染器代码运行在一个独立的线程中（非主UI线程），我们必须同时将该变量声明为volatile。注意下面声明该变量的代码，另外对应的get和set方法也被声明为了&lt;code&gt;public&lt;/code&gt;成员函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyGLRenderer implements GLSurfaceView.Renderer {
...

public volatile float mAngle;

public float getAngle() {
    return mAngle;
}

public void setAngle(float angle) {
    mAngle = angle;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;应用旋转&quot;&gt;&lt;a href=&quot;#应用旋转&quot; class=&quot;headerlink&quot; title=&quot;应用旋转&quot;&gt;&lt;/a&gt;应用旋转&lt;/h2&gt;&lt;p&gt;为了应用触控输入所生成的旋转，注释掉创建旋转角度的代码，然后添加mAngle，该变量包含了触控输入所生成的角度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onDrawFrame(GL10 gl) {
...
float[] scratch = new float[16];

// Create a rotation for the triangle
// long time = SystemClock.uptimeMillis() % 4000L;
// float angle = 0.090f * ((int) time);
Matrix.setRotateM(mRotationMatrix, 0, mAngle, 0, 0, -1.0f);

// Combine the rotation matrix with the projection and camera view
// Note that the mMVPMatrix factor *must be first* in order
// for the matrix multiplication product to be correct.
Matrix.multiplyMM(scratch, 0, mMVPMatrix, 0, mRotationMatrix, 0);

// Draw triangle
mTriangle.draw(scratch);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当完成了上述步骤，我们就可以运行这个程序，并通过手指在屏幕上的滑动旋转三角形了：&lt;br&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/opengl4.png&quot; alt=&quot;opengl4&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/android-training-geek/opengl-index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;转载&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;h
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="Android" scheme="http://jackliu17.github.io/tags/Android/"/>
    
      <category term="openGL_ES" scheme="http://jackliu17.github.io/tags/openGL-ES/"/>
    
      <category term="Android_API_Guides" scheme="http://jackliu17.github.io/tags/Android-API-Guides/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL_ES</title>
    <link href="http://jackliu17.github.io/2016/04/24/OpenGL-ES/"/>
    <id>http://jackliu17.github.io/2016/04/24/OpenGL-ES/</id>
    <published>2016-04-24T06:43:39.000Z</published>
    <updated>2016-04-24T06:57:33.000Z</updated>
    
    <content type="html">&lt;ol&gt;
&lt;li&gt;OpenGL 是跨平台的图像API，定义了3D图像处理的标准&lt;/li&gt;
&lt;li&gt;OpenGL ES是为OPenGL在嵌入式设备上的标准&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安卓支持如下OpenGL&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OpenGL ES 1.0 and 1.1 - This API specification is supported by Android 1.0 and higher.&lt;/li&gt;
&lt;li&gt;OpenGL ES 2.0 - This API specification is supported by Android 2.2 (API level 8) and higher.&lt;/li&gt;
&lt;li&gt;OpenGL ES 3.0 - This API specification is supported by Android 4.3 (API level 18) and higher.&lt;/li&gt;
&lt;li&gt;OpenGL ES 3.1 - This API specification is supported by Android 5.0 (API level 21) and higher.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OpenGL ES 3.0以上需要厂家在设备上安装某图像处理，Android4.3以上可能不支持OpenGL ES 3.0&lt;/p&gt;
&lt;h2 id=&quot;The-Basics&quot;&gt;&lt;a href=&quot;#The-Basics&quot; class=&quot;headerlink&quot; title=&quot;The Basics&quot;&gt;&lt;/a&gt;The Basics&lt;/h2&gt;&lt;p&gt;Android中两个class需要特别注意&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GLSurfaceView&lt;/code&gt;&lt;br&gt;这是一个view,用来绘画和管理对象，和SurfaceView很相似&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt;&lt;br&gt;在GLSurfaceView中绘画的接口，提供了必要的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;onSurfaceCreated():  //初始化环境&lt;/li&gt;
&lt;li&gt;onDrawFrame(): //绘画对象&lt;/li&gt;
&lt;li&gt;onSurfaceChanged(): //当界面改变时，比如屏幕旋转&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;OpenGL-ES-packages&quot;&gt;&lt;a href=&quot;#OpenGL-ES-packages&quot; class=&quot;headerlink&quot; title=&quot;OpenGL ES packages&quot;&gt;&lt;/a&gt;OpenGL ES packages&lt;/h3&gt;&lt;p&gt;OpenGL ES 1.0/1.1 API Packages&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.opengl
javax.microedition.khronos.opengles
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OpenGL ES 2.0 API Class&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.opengl.GLES20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OpenGL ES 3.0/3.1 API Packages&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android.opengl
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Declaring-OpenGL-Requirements&quot;&gt;&lt;a href=&quot;#Declaring-OpenGL-Requirements&quot; class=&quot;headerlink&quot; title=&quot;Declaring OpenGL Requirements&quot;&gt;&lt;/a&gt;Declaring OpenGL Requirements&lt;/h2&gt;&lt;p&gt;在AndroidManifest.xml中声明OpenGL版本要求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;For OpenGL ES 2.0:
&amp;lt;!-- Tell the system this app requires OpenGL ES 2.0. --&amp;gt;
&amp;lt;uses-feature android:glEsVersion=&amp;quot;0x00020000&amp;quot; android:required=&amp;quot;true&amp;quot; /&amp;gt;

For OpenGL ES 3.0:
&amp;lt;!-- Tell the system this app requires OpenGL ES 3.0. --&amp;gt;
&amp;lt;uses-feature android:glEsVersion=&amp;quot;0x00030000&amp;quot; android:required=&amp;quot;true&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;纹理压缩要求 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;supports-gl-texture&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Mapping-Coordinates-for-Drawn-Objects&quot;&gt;&lt;a href=&quot;#Mapping-Coordinates-for-Drawn-Objects&quot; class=&quot;headerlink&quot; title=&quot;Mapping Coordinates for Drawn Objects&quot;&gt;&lt;/a&gt;Mapping Coordinates for Drawn Objects&lt;/h2&gt;&lt;h2 id=&quot;Shape-Faces-and-Winding&quot;&gt;&lt;a href=&quot;#Shape-Faces-and-Winding&quot; class=&quot;headerlink&quot; title=&quot;Shape Faces and Winding&quot;&gt;&lt;/a&gt;Shape Faces and Winding&lt;/h2&gt;&lt;h2 id=&quot;OpenGL-Versions-and-Device-Compatibility&quot;&gt;&lt;a href=&quot;#OpenGL-Versions-and-Device-Compatibility&quot; class=&quot;headerlink&quot; title=&quot;OpenGL Versions and Device Compatibility&quot;&gt;&lt;/a&gt;OpenGL Versions and Device Compatibility&lt;/h2&gt;&lt;h2 id=&quot;Choosing-an-OpenGL-API-Version&quot;&gt;&lt;a href=&quot;#Choosing-an-OpenGL-API-Version&quot; class=&quot;headerlink&quot; title=&quot;Choosing an OpenGL API Version&quot;&gt;&lt;/a&gt;Choosing an OpenGL API Version&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html#choosing-version&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Abstract from Android API Guides - OpenGL&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;OpenGL 是跨平台的图像API，定义了3D图像处理的标准&lt;/li&gt;
&lt;li&gt;OpenGL ES是为OPenGL在嵌入式设备上的标准&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安卓支持如下OpenGL&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OpenGL ES 1.0 and 1.1 -
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="Android" scheme="http://jackliu17.github.io/tags/Android/"/>
    
      <category term="openGL_ES" scheme="http://jackliu17.github.io/tags/openGL-ES/"/>
    
      <category term="Android_API_Guides" scheme="http://jackliu17.github.io/tags/Android-API-Guides/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目6.UIScrollView图片自动滚动</title>
    <link href="http://jackliu17.github.io/2016/04/22/iOS%E9%A1%B9%E7%9B%AE6-UIScrollView%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8/"/>
    <id>http://jackliu17.github.io/2016/04/22/iOS项目6-UIScrollView图片自动滚动/</id>
    <published>2016-04-22T01:13:06.000Z</published>
    <updated>2016-05-11T06:06:49.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/uiscrollViewPlay.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;功能分析&quot;&gt;&lt;a href=&quot;#功能分析&quot; class=&quot;headerlink&quot; title=&quot;功能分析&quot;&gt;&lt;/a&gt;功能分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90.png&quot; alt=&quot;功能分析&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;定义常量的两种方式&quot;&gt;&lt;a href=&quot;#定义常量的两种方式&quot; class=&quot;headerlink&quot; title=&quot;定义常量的两种方式&quot;&gt;&lt;/a&gt;定义常量的两种方式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//屏幕高度
#define kScreenHeight [UIScreen mainScreen].bounds.size.height
//屏幕宽度
#define kScreenWidth [UIScreen mainScreen].bounds.size.width
//图像数量
CGFloat kImgCount = 10;
//Y轴坐标
CGFloat scrollY = 20;
//页面控制器宽度
CGFloat pageCtrlWidth = 200;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;UIScrollView的配置&quot;&gt;&lt;a href=&quot;#UIScrollView的配置&quot; class=&quot;headerlink&quot; title=&quot;UIScrollView的配置&quot;&gt;&lt;/a&gt;UIScrollView的配置&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//配置滚动视图的可见区域 -- 延伸出屏幕外的
self.scrollView.contentSize = CGSizeMake(kScreenWidth * kImgCount, kScreenHeight - scrollY);


//配置滚动视图可以页面显示
self.scrollView.pagingEnabled = YES;


//在滚动视图中实现图像偏移
[self.scrollView setContentOffset:point animated:YES];


//滚动视图滚动之后
- (void)scrollViewDidScroll:(UIScrollView *)scrollView{

}

//当视图将要拖动的时候
- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{

}

//当视图停止拖拽的时候
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;添加视图-插入&quot;&gt;&lt;a href=&quot;#添加视图-插入&quot; class=&quot;headerlink&quot; title=&quot;添加视图 - 插入&quot;&gt;&lt;/a&gt;添加视图 - 插入&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;[self.view insertSubview:self.pageCtrl aboveSubview:self.scrollView];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;定时器添加和停止&quot;&gt;&lt;a href=&quot;#定时器添加和停止&quot; class=&quot;headerlink&quot; title=&quot;定时器添加和停止&quot;&gt;&lt;/a&gt;定时器添加和停止&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;//创建定时器来调用翻页方法
self.timer = [NSTimer scheduledTimerWithTimeInterval:2.0
                                              target:self
                                            selector:@selector(nextPage)
                                            userInfo:nil
                                             repeats:YES];

//停止定时器
[self.timer invalidate];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;循环调用&quot;&gt;&lt;a href=&quot;#循环调用&quot; class=&quot;headerlink&quot; title=&quot;循环调用&quot;&gt;&lt;/a&gt;循环调用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;[[NSRunLoop currentRunLoop]addTimer:self.timer forMode:NSRunLoopCommonModes];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/uiscrollViewPlay.p
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="codeExample" scheme="http://jackliu17.github.io/tags/codeExample/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目5.UIPickerView国家选择</title>
    <link href="http://jackliu17.github.io/2016/04/20/iOS%E9%A1%B9%E7%9B%AE5-UIPickerView%E5%9B%BD%E5%AE%B6%E9%80%89%E6%8B%A9/"/>
    <id>http://jackliu17.github.io/2016/04/20/iOS项目5-UIPickerView国家选择/</id>
    <published>2016-04-20T07:14:27.000Z</published>
    <updated>2016-05-10T06:44:46.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%9B%BD%E5%AE%B6%E9%80%89%E6%8B%A9.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;项目架构&quot;&gt;&lt;a href=&quot;#项目架构&quot; class=&quot;headerlink&quot; title=&quot;项目架构&quot;&gt;&lt;/a&gt;项目架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%9B%BD%E5%AE%B6%E9%80%89%E6%8B%A92.png&quot; alt=&quot;项目架构&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;设置xib&quot;&gt;&lt;a href=&quot;#设置xib&quot; class=&quot;headerlink&quot; title=&quot;设置xib&quot;&gt;&lt;/a&gt;设置xib&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/UIPickerViewDataSource.png&quot; alt=&quot;设置xib&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据模型创建&quot;&gt;&lt;a href=&quot;#数据模型创建&quot; class=&quot;headerlink&quot; title=&quot;数据模型创建&quot;&gt;&lt;/a&gt;数据模型创建&lt;/h1&gt;&lt;p&gt;自定义国家子视图和数据模型的创建如前例&lt;/p&gt;
&lt;h1 id=&quot;滚轮中的每一行的视图设定&quot;&gt;&lt;a href=&quot;#滚轮中的每一行的视图设定&quot; class=&quot;headerlink&quot; title=&quot;滚轮中的每一行的视图设定&quot;&gt;&lt;/a&gt;滚轮中的每一行的视图设定&lt;/h1&gt;&lt;p&gt;因为是reuse的，所以不用像前例一样懒加载视图，只需要加载数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view{

JKCountryFlagView *countryView = (JKCountryFlagView *)view;

if (!countryView) {
    countryView = [JKCountryFlagView countryView];
}

countryView.countryModel = self.dataArray[row];

return countryView;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%9B%BD%E5%AE%B6
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="codeExample" scheme="http://jackliu17.github.io/tags/codeExample/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目4.应用程序管理</title>
    <link href="http://jackliu17.github.io/2016/04/20/iOS%E9%A1%B9%E7%9B%AE4-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86/"/>
    <id>http://jackliu17.github.io/2016/04/20/iOS项目4-应用程序管理/</id>
    <published>2016-04-20T02:07:50.000Z</published>
    <updated>2016-05-10T06:21:52.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;功能分析&quot;&gt;&lt;a href=&quot;#功能分析&quot; class=&quot;headerlink&quot; title=&quot;功能分析&quot;&gt;&lt;/a&gt;功能分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90.png&quot; alt=&quot;功能分析&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;freeform-UIView-in-Empty-XIB&quot;&gt;&lt;a href=&quot;#freeform-UIView-in-Empty-XIB&quot; class=&quot;headerlink&quot; title=&quot;freeform UIView in Empty XIB&quot;&gt;&lt;/a&gt;freeform UIView in Empty XIB&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/freeForm.png&quot; alt=&quot;设置xib为freeform&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ViewController&quot;&gt;&lt;a href=&quot;#ViewController&quot; class=&quot;headerlink&quot; title=&quot;ViewController&quot;&gt;&lt;/a&gt;ViewController&lt;/h1&gt;&lt;h2 id=&quot;定义常量&quot;&gt;&lt;a href=&quot;#定义常量&quot; class=&quot;headerlink&quot; title=&quot;定义常量&quot;&gt;&lt;/a&gt;定义常量&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//屏幕的高
#define kScreenH [UIScreen mainScreen].bounds.size.height
//屏幕的宽
#define kScreenW [UIScreen mainScreen].bounds.size.width
//应用界面的高
#define kAppViewH [JKAppView appView].bounds.size.height
//应用界面的宽
#define kAppViewW [JKAppView appView].bounds.size.width
//每行的个数
#define kTotalCol 3
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;加载plist中的数据&quot;&gt;&lt;a href=&quot;#加载plist中的数据&quot; class=&quot;headerlink&quot; title=&quot;加载plist中的数据&quot;&gt;&lt;/a&gt;加载plist中的数据&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (NSArray *)appViews{

    if (!_appViews) {

    NSString *path = [[NSBundle mainBundle]pathForResource:@&amp;quot;app&amp;quot; ofType:@&amp;quot;plist&amp;quot;];
    NSArray *array = [NSArray arrayWithContentsOfFile:path];
    NSMutableArray *arrayM = [NSMutableArray arrayWithCapacity:array.count];

    for (NSDictionary *dict in array) {

        JKAppInfo *appInfo = [JKAppInfo appInfoWithDict:dict];
        JKAppView *appView = [JKAppView appView];
        appView.appInfo = appInfo;
        appView.delegate = self;

        [arrayM addObject:appView];
    }
    _appViews = [arrayM copy];
}
return _appViews;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;列间距计算&quot;&gt;&lt;a href=&quot;#列间距计算&quot; class=&quot;headerlink&quot; title=&quot;列间距计算&quot;&gt;&lt;/a&gt;列间距计算&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;CGFloat margin = (kScreenW - kTotalCol * kAppViewW)/(kTotalCol + 1);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;九宫格加载视图&quot;&gt;&lt;a href=&quot;#九宫格加载视图&quot; class=&quot;headerlink&quot; title=&quot;九宫格加载视图&quot;&gt;&lt;/a&gt;九宫格加载视图&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//遍历应用界面数组
for (int i = 0 ; i&amp;lt;self.appViews.count; i++) {

    //根据索引值取出单个应用界面
    JKAppView *appView = self.appViews[i];

    //九宫格的算法创建每个应用界面
    int col = i % kTotalCol;
    int row = i / kTotalCol;

    CGFloat centerX = (margin + kAppViewW * 0.5) +(margin + kAppViewW) *col;
    CGFloat centerY = (margin + kAppViewH * 0.5) +(margin + kAppViewH) *row;

    appView.center = CGPointMake(centerX, centerY);
    //加入到主视图中
    [self.view addSubview:appView];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;根据点击的按钮获得相关视图&quot;&gt;&lt;a href=&quot;#根据点击的按钮获得相关视图&quot; class=&quot;headerlink&quot; title=&quot;根据点击的按钮获得相关视图&quot;&gt;&lt;/a&gt;根据点击的按钮获得相关视图&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;JKAppView *appView = (JKAppView*)btn.superview;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;菊花的frame值设定&quot;&gt;&lt;a href=&quot;#菊花的frame值设定&quot; class=&quot;headerlink&quot; title=&quot;菊花的frame值设定&quot;&gt;&lt;/a&gt;菊花的frame值设定&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;juhua.frame = self.view.bounds;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;菊花与”正在下载”标签&quot;&gt;&lt;a href=&quot;#菊花与”正在下载”标签&quot; class=&quot;headerlink&quot; title=&quot;菊花与”正在下载”标签&quot;&gt;&lt;/a&gt;菊花与”正在下载”标签&lt;/h2&gt;&lt;p&gt;因为”正在下载”标签是添加在菊花上的，所以当菊花停止时，标签也会自动消失&lt;/p&gt;
&lt;h2 id=&quot;标签逐渐消失-使用alpha&quot;&gt;&lt;a href=&quot;#标签逐渐消失-使用alpha&quot; class=&quot;headerlink&quot; title=&quot;标签逐渐消失 - 使用alpha&quot;&gt;&lt;/a&gt;标签逐渐消失 - 使用alpha&lt;/h2&gt;&lt;p&gt;其效果为隐式动画，重新设定alpha值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;noteLabel.alpha = 1;  
[self.view addSubview:noteLabel];

[UIView animateWithDuration:5.0 animations:^{
         noteLabel.alpha = 0; 
     } completion:^(BOOL finished) {
         .....
     }];
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;标签消失后&quot;&gt;&lt;a href=&quot;#标签消失后&quot; class=&quot;headerlink&quot; title=&quot;标签消失后&quot;&gt;&lt;/a&gt;标签消失后&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[UIView animateWithDuration:5.0 animations:^{

         noteLabel.alpha = 0; 
     } completion:^(BOOL finished) {

         btn.enabled = NO;
         [btn setTitle:@&amp;quot;已下载&amp;quot; forState:UIControlStateDisabled];
         [noteLabel removeFromSuperview];

     }];
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;JKAppInfo&quot;&gt;&lt;a href=&quot;#JKAppInfo&quot; class=&quot;headerlink&quot; title=&quot;JKAppInfo&quot;&gt;&lt;/a&gt;JKAppInfo&lt;/h1&gt;&lt;h2 id=&quot;字典加载数据模型&quot;&gt;&lt;a href=&quot;#字典加载数据模型&quot; class=&quot;headerlink&quot; title=&quot;字典加载数据模型&quot;&gt;&lt;/a&gt;字典加载数据模型&lt;/h2&gt;&lt;p&gt;属性名需要和plist中的字典key一一对应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (instancetype)initWithDict:(NSDictionary *)dict{

if (self=[super init]) {
    [self setValuesForKeysWithDictionary:dict];
}
return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;创建image图像&quot;&gt;&lt;a href=&quot;#创建image图像&quot; class=&quot;headerlink&quot; title=&quot;创建image图像&quot;&gt;&lt;/a&gt;创建image图像&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (UIImage *)image{
if (!_image) {
    _image = [UIImage imageNamed:self.icon];
}
return _image ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;JKAppView&quot;&gt;&lt;a href=&quot;#JKAppView&quot; class=&quot;headerlink&quot; title=&quot;JKAppView&quot;&gt;&lt;/a&gt;JKAppView&lt;/h1&gt;&lt;h2 id=&quot;协议方法-点击下载按钮&quot;&gt;&lt;a href=&quot;#协议方法-点击下载按钮&quot; class=&quot;headerlink&quot; title=&quot;协议方法-点击下载按钮&quot;&gt;&lt;/a&gt;协议方法-点击下载按钮&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;@protocol JKAppViewDelegate &amp;lt;NSObject&amp;gt;
@optional
-(void)downloadClickWithBtn:(UIButton*)btn;
@end

@interface JKAppView : UIView
@property (nonatomic,weak) id&amp;lt;JKAppViewDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;类与类之间的通讯，有三种方法：代理，通知，block&lt;/li&gt;
&lt;li&gt;协议就好像一个武器，类本身不能使用，于是叫他的小弟”id&lt;jkappviewdelegate&gt; delegate” ,交由他人(viewController)使用&lt;/jkappviewdelegate&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;调用代理执行&quot;&gt;&lt;a href=&quot;#调用代理执行&quot; class=&quot;headerlink&quot; title=&quot;调用代理执行&quot;&gt;&lt;/a&gt;调用代理执行&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- (IBAction)downloadBtnOnClick:(UIButton *)sender {

if ([self.delegate respondsToSelector:@selector(downloadClickWithBtn:)]) {

    [self.delegate downloadClickWithBtn:sender];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;UIView中加载XIB视图&quot;&gt;&lt;a href=&quot;#UIView中加载XIB视图&quot; class=&quot;headerlink&quot; title=&quot;UIView中加载XIB视图&quot;&gt;&lt;/a&gt;UIView中加载XIB视图&lt;/h2&gt;&lt;p&gt;UIView子类 + (Freeform View in Empty XIB)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)appView{
//因为只有一个object,所以first or last都可以
return [[[NSBundle mainBundle]loadNibNamed:@&amp;quot;JKAppView&amp;quot; owner:nil options:nil]lastObject];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xrh1x.com1.z0.glb.clouddn.com/%E5%BA%94%E7%94%A8
    
    </summary>
    
      <category term="IT" scheme="http://jackliu17.github.io/categories/IT/"/>
    
    
      <category term="iOS" scheme="http://jackliu17.github.io/tags/iOS/"/>
    
      <category term="codeExample" scheme="http://jackliu17.github.io/tags/codeExample/"/>
    
  </entry>
  
</feed>
