<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="D3Af5_wNyfCxpGOmu04o8yJ6Y4au_48rBuja2NxHLOs" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Cowboy Tech" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Cowboy Tech">
<meta property="og:url" content="http://jackliu17.github.io/page/20/index.html">
<meta property="og:site_name" content="Cowboy Tech">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cowboy Tech">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Cowboy Tech </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Cowboy Tech</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">The best preparation for tomorrow is doing your best today</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      


      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/Swift面向对象基础（中）/" itemprop="url">
                  Swift面向对象基础（中）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T12:04:36+11:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/12/Swift面向对象基础（中）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/12/Swift面向对象基础（中）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>存储在类，结构体里的变量或者常量，有两种:实例存储属性和类型存储属性</li>
<li>初始值要么在构造器中，要么在就直接赋予，可选类型的存储属性可以不指定初始值</li>
<li>系统会提供两个构造器：一个无参数的构造器和一个初始化所有实例存储属性的构造器。</li>
</ol>
<h2 id="结构体实例存储属性"><a href="#结构体实例存储属性" class="headerlink" title="结构体实例存储属性"></a>结构体实例存储属性</h2><pre><code>struct LengthRange {
var start: Int
//定义常量存储属性，可以不指定初始值
let length:Int
}

var len = LengthRange(start:9, length:3)
//通过构造器参数完成实例存储属性的初始化
print(&quot;len的起点为\(len.start),长度为\(len.length)&quot;)

len.start = 2
//len.length = 4 //这个会报错，因为是常量，常量是不能修改的
</code></pre><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>[修饰符]var计算属性名:属性类型{
get{
//get方法执行体，该方法一定要有返回值
}

set(形参名){
setter方法执行体，该方法一定不能有返回值
}

}
</code></pre><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><pre><code>class User{
var first:String = &quot;&quot;
var last:String = &quot;&quot;

//定义计算属性
var fullName:String{

    //定义计算属性的getter方法，该方法的返回值由first,last两个存储属性决定
    get{
        return first + &quot;-&quot; + last
    }

    //定义计算属性的setter方法
    //该setter方法将负责改变该实例的first,last两个存储属性
    set(newValue){
        var names = newValue.componentsSeparatedByString(&quot;-&quot;)
        self.first = names[0]
        self.last = names [1]
    }
}

init(first:String, last:String){
    self.first = first
    self.last = last
}
}

let s = User(first:&quot;极客&quot;,last:&quot;Hello&quot;)
//print(s.fullName) //结果是：极客-Hello

s.fullName = &quot;极客-学院&quot;
print(s.first)  //outcome is 极客
print(s.last)   //结果是 学院
</code></pre><h2 id="例子2-只读属性"><a href="#例子2-只读属性" class="headerlink" title="例子2 只读属性"></a>例子2 只读属性</h2><p>无需set部分，可以省略get和花括号</p>
<pre><code>class User{
var first:String = &quot;&quot;
var last:String = &quot;&quot;

//定义计算属性
var fullName:String{

//定义计算属性的getter方法，该方法的返回值由first,last两个存储属性决定
   return first + &quot;-&quot; + last

}

init(first:String, last:String){
   self.first = first
   self.last = last
}

}
</code></pre><h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><pre><code>[修饰符]var 计算属性名：属性类型 = 初始值 {
  willSet (newValue){
  //属性即将被赋值之前自动调用的方法

  }

  didSet(oldValue){
  //属性被赋值完成之后自动调用的方法

  }
}
</code></pre><ol>
<li>除了延迟存储属性之外的所有存储属性（包括实例存储属性和类型存储属性）</li>
<li>可通过重载方式为继承得到的属性（包括存储属性和计算属性）添加属性观察者。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>class Person {
//定义存储属性
var name: String = &quot;&quot;{

    willSet{

        if(newValue.characters.count &gt; 6 || newValue.characters.count &lt; 2){
            print(&quot;您设置的人名\(newValue)不符合要求，请重新设置！&quot;)
        }else{
            print(&quot;人名设置符合要求，设置成功&quot;)
        }
    }

    didSet{
        print(&quot;人名设置完成，被修改的原名为：\(oldValue)&quot;)
    }
}

var age: Int = 0{

    willSet{
        if newValue &gt; 100 || newValue &lt; 0{
            print(&quot;您设置的年龄\(newValue)不符合要求，请重新设置！&quot;)
        }else{
            print(&quot;年龄设置符合要求，设置成功&quot;)
        }
    }

    didSet {
        print(&quot;年龄设置完成，被修改的年龄为：\(oldValue)&quot;)
    }
}
}

var p = Person()
//p.age = 999  //不成功的设置，先调用willSet，再调用didSet
p.age = 10 // 成功的设置
print(&quot;成功设置年龄后，年龄为\(p.age)&quot;)  
</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>类型方法:枚举，结构体中方法使用static修饰，类中用class修饰，否则的话属于实例方法</p>
<h2 id="将方法转换为函数"><a href="#将方法转换为函数" class="headerlink" title="将方法转换为函数"></a>将方法转换为函数</h2><pre><code>class SomeClass {

func test() {
    print(&quot;==test 方法==&quot;)
}

class func bar(msg:String) {
    print(&quot;==bar类型方法==，传入的参数为:\(msg)&quot;)
}
}

var sc = SomeClass()     //创建实例
var f1:()-&gt;()=sc.test    //将sc的test方法分离成函数

var f2:(String) -&gt; Void = SomeClass.bar    //将sc的bar方法分离成函数，定义一个函数型的变量并赋值
//f1()    //等价于sc.test()
f2(&quot;极客&quot;)  //等价于SomeClass.bar(msg:&quot;Geek&quot;)
</code></pre><h2 id="方法形参名省略用-“-”"><a href="#方法形参名省略用-“-”" class="headerlink" title="方法形参名省略用 “_”"></a>方法形参名省略用 “_”</h2><p>默认除第一个参数外都添加了外部参数名，与局部参数名一样，如果不需要的话，则用_下划线的方式去掉</p>
<pre><code>class Person {

var name:String

init(name:String){
    self.name = name
}

func eat (food:String, _ drink:String, cigarette:String){
    print(&quot;\(self.name)吃着\(food),喝着\(drink),抽着\(cigarette)&quot;)
}
}

var p = Person(name:&quot;Tom&quot;)
p.eat(&quot;烤鸭&quot;,&quot;啤酒&quot;,cigarette:&quot;雪茄&quot;)
</code></pre><h2 id="值类型的可变方法可以改变存储属性"><a href="#值类型的可变方法可以改变存储属性" class="headerlink" title="值类型的可变方法可以改变存储属性"></a>值类型的可变方法可以改变存储属性</h2><pre><code>struct JKRect {
var x: Int
var y: Int
var width:Int
var height:Int
mutating func moveByX(x:Int,y:Int){
    self.x += x
    self.y += y
}
}

var rect = JKRect(x:20, y:12, width:200, height:300)   //创建实例
rect.moveByX(100, y:90)   //调用mutating方法，该方法可以改变rect实例的存储属性
print(&quot;rect矩形的左上角的x坐标为：\(rect.x),y坐标为:\(rect.y)&quot;)
</code></pre><ol>
<li>将mutating关键字放在func之前，即将该方法声明为可变方法</li>
<li>常量类型的结构体，枚举是不可变的,比如上述的var 改成 let就不行了</li>
</ol>
<h2 id="属性和方法的统一"><a href="#属性和方法的统一" class="headerlink" title="属性和方法的统一"></a>属性和方法的统一</h2><p>使用函数类型定义存储属性，并将函数或者闭包作为该属性的初始值，这个属性就成了方法</p>
<pre><code>func factorial(n:Int) -&gt; Int {
var result = 1
for i in 1...n {
    result *= i
}
return result
}

struct SomeStruct {
var info:() -&gt; Void = {
    print(&quot;info方法&quot;)
}
//将全局函数作为fact存储属性的初始值
static var fact:(Int) -&gt; Int = factorial
}

var sc = SomeStruct()
//调用info方法
//sc.info()  //outcome is info方法

//使用闭包对sc对象的info赋值，相当于重新定义sc的info方法
sc.info = {
print(&quot;另外一个闭包&quot;)
}

//sc.info()  //outcome is 另外一个闭包

var n = 6

//调用fact方法，执行的是阶乘
//print(&quot;\(n)的阶乘是：\(SomeStruct.fact(6))&quot;) //Outcome is 720

//使用闭包对SomeStruct的fact赋值，相当于重新定义SomeStruct的fact方法
SomeStruct.fact = {
var result = 1
for i in 1...$0 {
    result += i
}
return result
}

//再次调用fact方法，执行的是累加
print(&quot;\(n)的累加的和是:\(SomeStruct.fact(6))&quot;) //outcome is 22
</code></pre><h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><ol>
<li>所有的Swift类型（枚举，类，结构体）都支持定义下标</li>
<li>同一个类型可以定义多个下标，通过下标的形参列表或者返回值类型来区分不同的下标</li>
<li>同一类型中定义多个不同的下标被称为下标重载</li>
<li>形参列表：与函数的形参列表的用法基本相同，但是不支持指定外部参数和默认值</li>
<li>下标的返回值类型：可以是任何有效的类型   </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Subscripe(形参列表) -&gt;下标返回值类型 &#123;</span><br><span class="line">get &#123;</span><br><span class="line">  //getter方法执行体，该方法必须有返回值</span><br><span class="line">&#125;</span><br><span class="line">set(形参名)&#123;</span><br><span class="line">  //setter方法执行体，该方法不能有返回值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>struct JKRect2{
var x:Int
var y:Int
var width:Int
var height:Int

//定义下标，指定下标只接受一个Int类型的参数，下标的返回类型为Int

subscript(index:Int) -&gt;Int {

    get{
        switch(index){
        case 0:
            return self.x
        case 1:
            return self.y
        case 2:
            return self.width
        case 3:
            return self.height
        default:
            print(&quot;不支持该索引值&quot;)
            return 0
        }
    }

    set{
        switch(index){
        case 0:
            self.x = newValue
        case 1:
            self.y = newValue
        case 2:
            self.width = newValue
        case 3:
            self.height = newValue
        default:
            print(&quot;不支持该索引值&quot;)
        }
    }
}
}

//创建实例
var rect2 = JKRect2(x:20,y:12,width:200,height:300)

//通过下标进行赋值
//rect2[0] = 40
//rect2[1] = 67

//通过下标访问rect的属性
print(&quot;rect2矩形的左上角的x坐标为:\(rect2[0]),y坐标为:\(rect2[1])&quot;)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/Swift面向对象基础(上)/" itemprop="url">
                  Swift面向对象基础(上)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-11T18:06:33+11:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/11/Swift面向对象基础(上)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/11/Swift面向对象基础(上)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h1><ol>
<li>面向对象编程的三大特征：封装，继承，和多态</li>
<li>Swift可以定义枚举，结构体，和类三种面向对象的类型</li>
</ol>
<h1 id="Class-继承-引用类型"><a href="#Class-继承-引用类型" class="headerlink" title="Class - 继承/引用类型"></a>Class - 继承/引用类型</h1><ol>
<li>内存里的对象可以有多个引用，即多个引用变量指向同一个对象</li>
<li>如果一个引用更改了，那对象里的值也会更改。</li>
<li>“===” 这个等号只能用于引用类型的比较，不能用于值类型的比较，所以不能用于枚举或者结构体</li>
<li>“==” or “!=” ,这两个也可以用于比较引用类型，但是要用到运算符重载，详情见后期课程</li>
</ol>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>必须有init method</p>
<pre><code>class Movie {

    let title: String
    let director: String
    let releaseYear: Int

    init(title: String, director: String, releaseYear: Int) {
        self.title = title
        self.director = director
        self.releaseYear = releaseYear
    }
}
</code></pre><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><p>三类property: Stored property, Type properties, Computed property</p>
<p>默认是internal，就是可以app内访问</p>
<p><img src="https://www.dropbox.com/s/5rjjtamvk1890kv/20160902_property.png?dl=1" alt="1"></p>
<h3 id="Stored-property"><a href="#Stored-property" class="headerlink" title="Stored property"></a>Stored property</h3><p>大多数的stored property 是定义为常量，必须在init的时候被设定,external name 在init method中是必须的</p>
<pre><code>var thursdayNightMovie = Movie(title:&quot;Point Break&quot;, director:&quot;Kathryn Bigelow&quot;, releaseYear: 1991)
</code></pre><h3 id="Type-properties-amp-Computed-Properties"><a href="#Type-properties-amp-Computed-Properties" class="headerlink" title="Type properties &amp; Computed Properties"></a>Type properties &amp; Computed Properties</h3><pre><code>class KidsMovie {
    let title: String
    let director: String
    let releaseYear: Int
    var mpaaRating: String

    //Type property
    static let permittedRatings = [&quot;G&quot;, &quot;PG&quot;]

    let reviewScores:[Double]

    var metaScore: Double {
        get {
            let value = reviewScores.reduce(0) { $0 + $1 } / Double(reviewScores.count)
            return value
        }
    }

    init(title: String, director: String, releaseYear: Int, mpaaRating:String, reviewScores: [Double]) {
        self.mpaaRating = mpaaRating
        self.title = title
        self.director = director
        self.releaseYear = releaseYear
        self.reviewScores = reviewScores
    }
}
</code></pre><h2 id="Calling-Type-methods"><a href="#Calling-Type-methods" class="headerlink" title="Calling Type methods"></a>Calling Type methods</h2><pre><code>UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceType.PhotoLibrary)
</code></pre><p>使用class func ，子类可以重载，使用static则不会</p>
<pre><code>class Hello {

let pipi:String

init (hello:String){
    self.pipi = hello
}

//or class func .....
static func diao (hello:String){
print(&quot;why&quot;)
}
}
</code></pre><h1 id="Enumeration-不能继承-值类型"><a href="#Enumeration-不能继承-值类型" class="headerlink" title="Enumeration - 不能继承/值类型"></a>Enumeration - 不能继承/值类型</h1><ol>
<li>值对象是要复制的</li>
<li>每个值对象的更改，不会影响其他对象的更改</li>
<li>因此枚举和结构体是没有继承的  </li>
</ol>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Enum可以看做是一组有限的“抽象概念”的集合 (数组需要指定具体的数值类型)</p>
<pre><code>enum PrimaryColor {
    case Red
    case Blue
    case Yellow
}
</code></pre><p>可以用一个case,然后其他用逗号隔开</p>
<pre><code>enum Aunties {
    case Aime, Billie, Diane, Gail, Janie, Pam
}
</code></pre><p>enum中的元素可以设定任何类型原始值,如string,int</p>
<pre><code>enum AmericanLeagueWest: String {
    case As = &quot;Oakland&quot;
    case Astros = &quot;Houston&quot;
    case Angels = &quot;Los Angeles&quot;
    case Mariners = &quot;Seattle&quot;
    case Rangers = &quot;Arlington&quot;    
}

var weather: AmericanLeagueWest
weather = AmericanLeagueWest.As
weather = .As //也可以这样写
</code></pre><p>使用rawValue提取成员的原始值</p>
<pre><code>var message = &quot;I hope the A&apos;s stay in \(AmericanLeagueWest.As.rawValue)&quot;
</code></pre><h2 id="Enums-and-switch"><a href="#Enums-and-switch" class="headerlink" title="Enums and switch"></a>Enums and switch</h2><pre><code>enum CaliforniaPark {
    case Yosemite, DeathValley, Lasson, Sequoia
}

var warning = &quot;&quot;
var destination = CaliforniaPark.Yosemite
</code></pre><p>例子 1：switch中的case如果没有覆盖枚举的所有值，必须添加default语句</p>
<pre><code>switch destination {
    case .Yosemite:
        warning = &quot;Beware of aggressive bears!&quot;
    case .DeathValley:
        warning = &quot;Beware of dehydration!&quot;
    case .Lasson:
        warning = &quot;Watch out for boiling pools!&quot;
    case .Sequoia:
        warning = &quot;Watch out for falling trees!&quot;
}
</code></pre><p>例子 2：</p>
<pre><code>// Below is an enum and an if-else statement for implementing the game Rock-Paper-Scissors.
enum roshamboMove {
    case Rock, Paper, Scissors
}

var myMove = roshamboMove.Scissors
var yourMove = roshamboMove.Scissors

var resultsMessage = &quot;&quot;

if myMove == .Rock &amp;&amp; yourMove == .Paper || myMove == .Paper &amp;&amp; yourMove == .Rock {
    resultsMessage = &quot;Paper covers Rock.&quot;
} else if myMove == yourMove {
    resultsMessage = &quot;It&apos;s a tie!&quot;
} else if myMove == .Rock &amp;&amp; yourMove == .Scissors || myMove == .Scissors &amp;&amp; yourMove == .Rock {
    resultsMessage = &quot;Rock crushes Scissors. &quot;
} else if myMove == .Paper &amp;&amp; yourMove == .Scissors || myMove == .Scissors &amp;&amp; yourMove == .Paper {
    resultsMessage = &quot;Scissors cut Paper.&quot;
} 

// Solution
switch (myMove, yourMove) {
case (.Rock, .Paper), (.Paper, .Rock):
    resultsMessage = &quot;Paper covers Rock.&quot;
case (.Rock, .Rock), (.Paper, .Paper), (.Scissors, .Scissors):
    resultsMessage = &quot;It&apos;s a tie!&quot;
case (.Rock, .Scissors), (.Scissors, .Rock):
    resultsMessage = &quot;Rock crushes Scissors.&quot;
case (.Paper, .Scissors), (.Scissors, .Paper):
    resultsMessage = &quot;Scissors cut Paper.&quot;
}

// Alternate solution
switch (myMove, yourMove) {
case (.Rock, .Paper), (.Paper, .Rock):
    resultsMessage = &quot;Paper covers Rock.&quot;
case let (a, b) where a==b :
    resultsMessage = &quot;It&apos;s a tie!&quot;
case (.Rock, .Scissors), (.Scissors, .Rock):
    resultsMessage = &quot;Rock crushes Scissors.&quot;
case (.Paper, .Scissors), (.Scissors, .Paper):
    resultsMessage = &quot;Scissors cut Paper.&quot;
default:
    resultsMessage = &quot;Paper covers Rock.&quot;
}
</code></pre><p>例子3</p>
<pre><code>var score = 97
var letterGrade = &quot;&quot;

// Solution
switch score {
case 90...100:
    letterGrade = &quot;A&quot;
case 80...89:
    letterGrade = &quot;B&quot;
case 70...79:
    letterGrade = &quot;C&quot;
case 60...69:
    letterGrade = &quot;D&quot;
default:
    letterGrade = &quot;Incomplete&quot;
}
</code></pre><h2 id="整型的枚举"><a href="#整型的枚举" class="headerlink" title="整型的枚举"></a>整型的枚举</h2><pre><code>//可以自动推断，不用每个都赋予原始值
enum Weekday: Int{
  case Mon, Tur, Wen = 3, Thur, Fri, Sat , Sun
}
</code></pre><h2 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h2><pre><code>//必须每个都赋予原始值，因为不能自动推断
enum Season3: Character{
  case Spring = &quot;春&quot;
  case Summer = &quot;夏&quot;
  case Fall = &quot;秋&quot;
  case Winter = &quot;冬&quot;
}
</code></pre><h2 id="获取枚举值"><a href="#获取枚举值" class="headerlink" title="获取枚举值"></a>获取枚举值</h2><pre><code>var mySeason = Season3(rawValue:&quot;春&quot;)
if mySeason != nil {
  switch(mySeason!){ //不为空才能进行强制解析
  case .Spring:
    print(&quot;春天不是读书天&quot;)
  case .Summer:
    print(&quot;夏天炎炎正好眠&quot;)
  case .Fall , .Winter:
    print(&quot;秋多蚊蝇冬日冷&quot;)
  default:
    print(&quot;读书只好等明年&quot;)

  }
}
</code></pre><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><pre><code>enum Planet {
case Earth(weight: Double , name:String)
case Mars (density: Double, name: String, weight:Double)
case Venus(Double, String)
case Saturn
case Neptune
}

var p1 = Planet.Earth(weight:1.0, name:&quot;地球&quot;)
var p2 = Planet.Venus(0.815,&quot;金星&quot;)
var p3 = Planet.Mars(density:3.95, name:&quot;火星&quot;,weight:0.1)

switch (p3){
//将关联值绑定到变量或者常量来提取
case Planet.Earth(var weight , var name):
   print(&quot;此行星的名字为:\(name),质量相当于\(weight)个地球&quot;)

//将关联值都提取为常量或者变量，只将一个var或者let放在枚举成员之前
case let Planet.Mars(density:d, name:n, weight:w):
   print(&quot;此行星的名字为:\(n),质量相当于\(w)个地球，密度为\(d)&quot;)
default:
   break
}
</code></pre><h1 id="Struct-不能继承-值类型"><a href="#Struct-不能继承-值类型" class="headerlink" title="Struct - 不能继承/值类型"></a>Struct - 不能继承/值类型</h1><pre><code>struct PictureFrame {
    var width = 5
    var height = 7
    var thickness: Double = 1.5

    var area: Int {
        get {
            return (width * height)/2
        }
    }
}
</code></pre><p>Struct自动生成init method </p>
<pre><code>var familyReunionFrame = PictureFrame(width: 10, height: 8, thickness: 1.5)
familyReunionFrame.area
</code></pre><h1 id="enum-class-or-struct"><a href="#enum-class-or-struct" class="headerlink" title="enum, class, or struct?"></a>enum, class, or struct?</h1><p> 只是单纯的存储数据，不需要继承</p>
<pre><code> Struct Triangle {
    let angles = [30, 60, 90]
    let sides = [3,4,5]
}
</code></pre><p> 存储“有限“的“成员”，不必考虑什么类型的数值</p>
<pre><code>enum UIImagePickerControllerSourceType : Int {    
    case PhotoLibrary
    case Camera
    case SavedPhotosAlbum
}
</code></pre><p>只是单纯的存储数据，不需要继承</p>
<pre><code>Struct Name {
    var firstName: String
    var lastName: String
}
</code></pre><p> 存储“有限“的“成员”，不必考虑什么类型的数值</p>
<pre><code>enum Subject {
    case Math
    case English
    case Spanish
    case Science
}
</code></pre><p> 有各种类型的学生，大学，中学，意味着需要继承</p>
<pre><code>class Student {
    var grades = [97.0, 99.0, 98.0]
    let name = Name(firstName:&quot;Grace&quot;, lastName:&quot;Hopper&quot;)
    var favoriteSubject = Subject.Science

    var gradePointAverage: Double {
        get {
            return (grades.reduce(0){$0 + $1})/Double (grades.count)
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/Swift中的函数和闭包/" itemprop="url">
                  Swift中的函数和闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-11T12:38:16+11:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/11/Swift中的函数和闭包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/11/Swift中的函数和闭包/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的种类和声明"><a href="#函数的种类和声明" class="headerlink" title="函数的种类和声明"></a>函数的种类和声明</h2><h3 id="Global-Functions"><a href="#Global-Functions" class="headerlink" title="Global Functions"></a>Global Functions</h3><p>在文件中的任何地方都可以调用，比如:</p>
<pre><code>print(&quot;I&apos;m a global function!&quot;)
</code></pre><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>在某个class里声明，需要用对象来调用，比如</p>
<pre><code>let array = [&quot;A&quot;, &quot;13&quot;, &quot;B&quot;,&quot;5&quot;,&quot;87&quot;, &quot;t&quot;, &quot;41&quot;]

class Arithmetic {
func sumOfStrings(aBunchOfStrings: [String]) -&gt; Int {
    let array = aBunchOfStrings
    var sum = 0
    for string in array {
        if Int(string) != nil {
            let intToAdd = Int(string)!
            sum += intToAdd
        }
    }
    return sum
}
}
</code></pre><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><pre><code>func functionName (parameterName: parameterType) -&gt; returnType {
    statements to execute
    return object
 }
</code></pre><h3 id="外部参数名"><a href="#外部参数名" class="headerlink" title="外部参数名"></a>外部参数名</h3><pre><code>func functionName (externalParameterName localParameterName: parameterType) -&gt; returnType {
    statements to execute
    return object
 }
</code></pre><p>比如</p>
<pre><code>func area (宽 width:Double ,高 height:Double ) -&gt;Double {

return width * height
}

print (area(宽:3.4,高:4.7)) //宽和高为外部函数名
</code></pre><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><pre><code>func sum(numbers:Int...)-&gt;Int {
var total: Int = 0
for num in numbers {
   total += num
}
print(total)
return total
}
sum(1,3,4,5)
</code></pre><ol>
<li>在参数类型后面添加…表示该参数可以接受多个参数值</li>
<li>一个函数当中只有一个数组参数,并且位于列表的最后</li>
</ol>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> func sayHi(msg:String, name:String=&quot;Lily&quot;)&#123;</span><br><span class="line"> print (&quot;\(name),\(msg)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">sayHi(&quot;Welcome to our city&quot;) //目前只传入了一个参数，如果第二个参数没传入，就使用默认值</span><br><span class="line">sayHi(&quot;Welcome to our city&quot;, name:&quot;Tom&quot;) //如果传入了，就使用传入的新值</span><br></pre></td></tr></table></figure>
<h3 id="忽略形参名，添加下划线"><a href="#忽略形参名，添加下划线" class="headerlink" title="忽略形参名，添加下划线 _"></a>忽略形参名，添加下划线 _</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sayHi(msg:String, _name:String=&quot;Lily&quot;)&#123; </span><br><span class="line"> print (&quot;\(name),\(msg)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">sayHi(&quot;Welcome to our city&quot;,&quot;Tom&quot;)</span><br></pre></td></tr></table></figure>
<p>如果函数里有可变参数也有默认参数，数组参数放在最后面，默认参数出现在次后面</p>
<h3 id="变量形参"><a href="#变量形参" class="headerlink" title="变量形参"></a>变量形参</h3><p>因为传入的参数是常量，如果需要在函数内进行变动数据的话，需要先设个变量 (swift 3)</p>
<pre><code>func placeFirstLetterLast(myString: String) -&gt; String {

var newString = myString
newString.append(firstCharacterOf(word: myString))
newString.removeAtIndex(myString.startIndex)
return newString
}

placeFirstLetterLast(&quot;Mom&quot;)
</code></pre><p>swift2的解决办法。swift3将取消</p>
<pre><code>//这里的形参是个变量，如果去掉var就是个常量，因为形参默认是常量constant
func factorial(var number:Int) -&gt; Int{
var result:Int = 1
while number &gt; 1 {
    result = result * number
    number -= 1
}
return result
}
print(factorial(3))
</code></pre><h3 id="In-out形参"><a href="#In-out形参" class="headerlink" title="In-out形参"></a>In-out形参</h3><pre><code>func swap (inout a:Int, inout b:Int){
let tmp = a
a = b
b = tmp
}

var a:Int = 1
var b:Int = 3
swap(&amp;a,&amp;b)
print(&quot;交换之后的结构为:a=\(a),b=\(b)&quot;)
</code></pre><ol>
<li>In-out参数就是强制传递变量的指针，因为在swift里，大多是值类型，而不是指针类型</li>
<li>只能传入变量作为实参</li>
<li>输入输出不能带有默认值</li>
<li>如果你用关键字inout标记了一个参数，这个参数不能再用var或者let去标记</li>
</ol>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>没有指定返回类型的函数总返回void,在swift中，void可以理解为空元组</p>
<pre><code>func sayHi2(){
print(&quot;welcome&quot;)
}
sayHi2()
</code></pre><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><pre><code>func area(width:Double,height:Double)-&gt;(Double,Double){
let s = width * height
let c = (width + height) * 2
return (s,c)
}
print(area(3.1, height: 3.4))
</code></pre><h2 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h2><h3 id="函数作为变量"><a href="#函数作为变量" class="headerlink" title="函数作为变量"></a>函数作为变量</h3><pre><code>func addTwoInts(a:Int,b:Int)-&gt;Int{
return a+b
}

func multiplyTwoInts(a:Int,b:Int)-&gt;Int{ 
return a*b
}

var mathFunction:(Int,Int) -&gt; Int = multiplyTwoInts
print(&quot;Result:\(mathFunction(2,3))&quot;)
</code></pre><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><pre><code>func addTwoInts(a:Int,b:Int)-&gt;Int{
return a+b
}

func multiplyTwoInts(a:Int,b:Int)-&gt;Int{
return a*b
}

func printMathResult(mathFunction:(Int,Int)-&gt;Int,a:Int,b:Int){
print(&quot;Result:\(mathFunction(a,b))&quot;)
}

printMathResult(addTwoInts,a: 3,b: 5)
</code></pre><h3 id="函数类型作为返回值类型"><a href="#函数类型作为返回值类型" class="headerlink" title="函数类型作为返回值类型"></a>函数类型作为返回值类型</h3><pre><code>func squre(num:Int) -&gt;Int{
return num * num
}

func cube(num:Int) -&gt;Int{
return num * num * num
}

func getMathFunc (jack: String)-&gt; (Int)-&gt;Int {

switch (jack){
case &quot;squre&quot;:
    return squre
default:
    return cube
}
}

var mathFunc = getMathFunc(&quot;other&quot;) // 返回的值是需要传入整数的函数
print(mathFunc(5)) //所以这里传入整数
</code></pre><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>形参和返回值不一样的同名函数</p>
<pre><code>//1.
func test(){
print(&quot;无参数的test()函数&quot;)
}

//2.
func test (msg: String){
print(&quot;重载的test()函数\(msg)&quot;)
}

//3.
func test(msg: String) -&gt; String {
print(&quot;重载的test()函数\(msg),带返回值&quot;)
return &quot;test&quot;
}

//4 这不算重载, 仅有形参名一样是不行的
func test(message:String){
print(&quot;重载的test()函数\(message)&quot;)
}

//调用1
test()

//调用2
var result:Void = test(&quot;Jike&quot;)

//调用3
var result2: String = test(&quot;Welcome , Geek&quot;)
</code></pre><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>函数体内部所定义的函数</p>
<pre><code>func getMathFunc(jackliu: String) -&gt; (Int) -&gt;Int{

func squre (num:Int) -&gt; Int{
    return num * num
}

func cube (num:Int) -&gt;Int{
    return num * num * num
}

switch(jackliu){
case &quot;squre&quot;:
    return squre
default: 
    return cube
}
}

var mathFunc:(Int)-&gt;Int  = getMathFunc (&quot;squre&quot;)
var mathFunc = getMathFunc (&quot;squre&quot;) // 这样写说明即使不写变量的类型，系统也会进行推断
print(mathFunc(4)) //outcome is 16

mathFunc = getMathFunc (&quot;other&quot;)
print(mathFunc(4)) //outcome is 64
</code></pre><h1 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h1><p>一段可以作为参数传递给函数的代码</p>
<pre><code>{ (parameters) -&gt; return type in

 statements to execute

}
</code></pre><p> 例子</p>
<pre><code>var bids = [48.1, 75.4, 63.7, 52.4, 68.2]
var orderedBids = bids.sort( {(bid1: Double, bid2:Double) -&gt; Bool in
    return  bid2 &gt; bid1
})
print(orderedBids)
</code></pre><h2 id="Closure的简写形式"><a href="#Closure的简写形式" class="headerlink" title="Closure的简写形式"></a>Closure的简写形式</h2><p>Example -  原有形式</p>
<pre><code>var soups = [&quot;tomato&quot;, &quot;hot and sour&quot;, &quot;french onion&quot;, &quot;vegetable&quot;]
var alphabeticalSoups = soups.sort({(soup1: String, soup2: String) -&gt; Bool in
    return soup2 &gt; soup1
})
</code></pre><p>Example - 简写 ($0,$1,$2….分别代表第几个参数)</p>
<pre><code>var soups = [&quot;tomato&quot;, &quot;hot and sour&quot;, &quot;french onion&quot;, &quot;vegetable&quot;]
var hello = soups.sort({

    $1 &gt; $0

})   
</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><pre><code>func getMathFunc(jackliu: String) -&gt; (Int) -&gt;Int{

switch(jackliu){
case &quot;squre&quot;:
    return { (num: Int) -&gt; Int in
        return num * num
    }
default:
    return { (num:Int) -&gt; Int in
        return num * num * num

    }
}
}

var mathFunc = getMathFunc(&quot;squre&quot;)
print(mathFunc(5)) //outcome is 25
mathFunc = getMathFunc (&quot;other&quot;)
print(mathFunc(5)) //outcome is 125
</code></pre><h2 id="利用上下文推断类型"><a href="#利用上下文推断类型" class="headerlink" title="利用上下文推断类型"></a>利用上下文推断类型</h2><p>Swift可以推断闭包的形参类型和返回值类型<br>函数和闭包是统一的，函数和闭包都是引用类型，当赋值给变量时，不会复制，而是指向同一个闭包   </p>
<p>省略形参类型，因为从左侧就可以推断了</p>
<pre><code>var squre:(Int) -&gt; Int = {(num) in return num * num}
print(squre(3))   //outcome is 9
</code></pre><p>因为可以推断，所以小括号也是可以省略的</p>
<pre><code>var squre:(Int) -&gt; Int = {num in return num * num}
print(squre(3))   //outcome is 9
</code></pre><p>如果闭包表达式只有一行代码，而且这行代码就是返回值，也可以省略return。通过$0,$1…来引用第一个，第二个参数</p>
<pre><code>var squre:(Int) -&gt; Int = {$0 * $0}
print(squre(3))  //out come is 9

var result: Int = { //这里的Int不是返回值类型，而是形参
    var result = 1
for i in 1...$1{
   result *= $0
}
return result
}(4,3)
print(result) //outcome is 64
</code></pre><h2 id="捕获上下文中的变量或者常量"><a href="#捕获上下文中的变量或者常量" class="headerlink" title="捕获上下文中的变量或者常量"></a>捕获上下文中的变量或者常量</h2><p>闭包（嵌套函数）可以访问或者修改其所在上下文中的变量或常量</p>
<pre><code>func makeArr(ele:String) -&gt; () -&gt; [String]{

//创建一个不包含任何元素的数组
var arr: [String] = []
func addElement() -&gt;[String]{

//向arr数组中添加一个元素
arr.append(ele)

return arr
}
return addElement
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/Swift中的字符串和集合/" itemprop="url">
                  Swift中的字符串和集合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-10T19:26:25+11:00" content="2016-03-10">
              2016-03-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/10/Swift中的字符串和集合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/10/Swift中的字符串和集合/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><p>表现形式</p>
<pre><code>var dollarSign: Character = &quot;$&quot;
var myFirstSwiftString: String = &quot;mo&apos; money&quot;
var mySecondSwiftString: String = &quot;mo&apos; problems&quot;
var concatenatedString = myFirstSwiftString + &quot;, &quot; + mySecondSwiftString

//显示其类型
concatenatedString.dynamicType
</code></pre><p>遍历字符串中的字符数组</p>
<pre><code>var password = &quot;Meet me in St. Louis&quot;
for character in password.characters {
if character == &quot;e&quot; {
    print(&quot;found an e!&quot;)
} else {
}
}
</code></pre><h2 id="字符串中取值字符"><a href="#字符串中取值字符" class="headerlink" title="字符串中取值字符"></a>字符串中取值字符</h2><p>尾字符</p>
<pre><code>var lastLetter = word.removeAtIndex(word.endIndex.predecessor())
</code></pre><p>首字符</p>
<pre><code>var firstLetter = word.removeAtIndex(word.startIndex)
</code></pre><h2 id="将字符串转成数组，取出第一个"><a href="#将字符串转成数组，取出第一个" class="headerlink" title="将字符串转成数组，取出第一个"></a>将字符串转成数组，取出第一个</h2><pre><code>var word = &quot;tan&quot;
var firstLetter = Array(word.characters)[0]
</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h2><p>纯字符串</p>
<pre><code>var s:Character = &quot;美&quot;
var quote1 = &quot;\&apos;&quot;
var quote2 = &quot;\u{22}&quot;
</code></pre><p>带变量的字符串</p>
<pre><code>print(&quot;quote1的值为:\(quote1),quote2的值为:\(quote2)&quot;)
</code></pre><p>带表达式的字符串</p>
<pre><code>var lbsPerDay = 0.75
var daysPerMonth:Double = 30.0
doggyDiet = &quot;\(dogName) eats \(lbsPerDay * daysPerMonth)lbs of dog food per month&quot;
</code></pre><p>Swift中的字符串是结构体，而NSString中的字符串是Class.Swift中的字符串也可以使用NSString方法</p>
<pre><code>let newPassword = password.stringByReplacingOccurrencesOfString(&quot;e&quot;, withString: &quot;3&quot;)
</code></pre><ol>
<li>单个字符来指定字符常量，如“A”，“9”</li>
<li>转义字符表示特殊字符常量，如”\n”,”\t”</li>
<li>使用\u{n}的Unicode形式，n代表一个1~8位的十六进制</li>
<li>必须用双引号包起来</li>
<li>Swift中的每一个字符代表了一个可扩展字母集</li>
</ol>
<h2 id="字符串创建"><a href="#字符串创建" class="headerlink" title="字符串创建"></a>字符串创建</h2><h3 id="方法1：直接赋值"><a href="#方法1：直接赋值" class="headerlink" title="方法1：直接赋值"></a>方法1：直接赋值</h3><pre><code>var str1 = &quot;Jike&quot;
</code></pre><h3 id="方法2：构造函数"><a href="#方法2：构造函数" class="headerlink" title="方法2：构造函数"></a>方法2：构造函数</h3><pre><code>var str2 = String()

//创建多个重复字符的字符串
var str3 = String(count:4,repeatedValue:Character(&quot;a&quot;))
var strRep = String(count:4,repeatedValue:UnicodeScalar(&quot;xxxxx&quot;)) //使用unicode
print(strRep)
</code></pre><h3 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h3><pre><code>// Here&apos;s one way to initialize an empty Swift string
var characterPoorString = &quot;&quot;

// And here&apos;s another 
let potentialRichString = String()
characterPoorString.characters
</code></pre><h2 id="字符串是否为空"><a href="#字符串是否为空" class="headerlink" title="字符串是否为空"></a>字符串是否为空</h2><pre><code>print(str3.isEmpty)
</code></pre><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><h3 id="方式1-用-“-”"><a href="#方式1-用-“-”" class="headerlink" title="方式1.用 “+”"></a>方式1.用 “+”</h3><pre><code>var str4 = str1 + &quot;College&quot;
str1 += &quot;Hello&quot;
print(str4)
</code></pre><h3 id="方式2-用append"><a href="#方式2-用append" class="headerlink" title="方式2.用append"></a>方式2.用append</h3><pre><code>let char:Character = &quot;!&quot;
str1.append(char)
print(str1)
</code></pre><h2 id="字符数量"><a href="#字符数量" class="headerlink" title="字符数量"></a>字符数量</h2><h3 id="Swift1-x"><a href="#Swift1-x" class="headerlink" title="Swift1.x"></a>Swift1.x</h3><pre><code>print(&quot;str3 has \(countElements(str3)) characters&quot;)
</code></pre><h3 id="Swift2-x"><a href="#Swift2-x" class="headerlink" title="Swift2.x"></a>Swift2.x</h3><pre><code>print(&quot;str3 has \(str4.characters.count) characters&quot;)
</code></pre><h3 id="这两种的输出结果不一样"><a href="#这两种的输出结果不一样" class="headerlink" title="这两种的输出结果不一样"></a>这两种的输出结果不一样</h3><pre><code>var nWithTilde = &quot;\u{006E}\u{0303}&quot;
nWithTilde.unicodeScalars.count
nWithTilde.characters.count  //通常用这个
</code></pre><ol>
<li>Swift中的Unicode16Count函数所获得的值，才是和NSString中的length一样。因为SWIFT的count是基于Unicode，而OC的length是基于UTF-16</li>
<li>Swift中的字符串是否可以修改仅通过定义的是变量还是常量来决定,也就是var or let</li>
</ol>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><pre><code>let quotation = &quot;We are the same&quot;
let sameQuotation = &quot;We are the same&quot;
if quotation == sameQuotation {
print(&quot;These are the same&quot;)
}
</code></pre><h2 id="字符串是否有特定的前缀后缀"><a href="#字符串是否有特定的前缀后缀" class="headerlink" title="字符串是否有特定的前缀后缀"></a>字符串是否有特定的前缀后缀</h2><pre><code>var food = [&quot;Fruits:apple&quot;,
&quot;Fruits : orange&quot;,
&quot;Fruits : banana&quot;,
&quot;Vegetables: tomato&quot;,
&quot;Vegetables: potato&quot;]

for fry in food{
if fry.hasPrefix(&quot;Fruits&quot;){
   print(fry)
}

if fry.hasSuffix(&quot;o&quot;){
   print(fry)
}
}
</code></pre><h2 id="字符串是否包含某子字符串"><a href="#字符串是否包含某子字符串" class="headerlink" title="字符串是否包含某子字符串"></a>字符串是否包含某子字符串</h2><pre><code>let word = &quot;fortunate&quot;
if word.rangeOfString(&quot;tuna&quot;) != nil {
print(&quot;yes&quot;)
}
</code></pre><h2 id="替换子字符串"><a href="#替换子字符串" class="headerlink" title="替换子字符串"></a>替换子字符串</h2><pre><code>let lottaLikes = &quot;If like, you wanna learn Swift, like, you should build lots of small apps, cuz it&apos;s like, a good way to practice.&quot;

let noLikes = lottaLikes.stringByReplacingOccurrencesOfString(&quot;like, &quot;, withString: &quot;&quot;)
</code></pre><h2 id="字符串转为整形"><a href="#字符串转为整形" class="headerlink" title="字符串转为整形"></a>字符串转为整形</h2><h3 id="Swift-1-x"><a href="#Swift-1-x" class="headerlink" title="Swift 1.x"></a>Swift 1.x</h3><pre><code>let myString: String = &quot;256&quot;
let myInt: Int? = myString.toInt()
</code></pre><h3 id="Swift-2-x"><a href="#Swift-2-x" class="headerlink" title="Swift 2.x"></a>Swift 2.x</h3><pre><code>let myString: String = &quot;256&quot;
let myInt: Int? = Int(myString)
</code></pre><h2 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h2><pre><code>let didYouKnowString = &quot;Did you know that the Swift String class comes with lots of useful methods?&quot;
let whisperString = &quot;psst&quot; + &quot;, &quot; + didYouKnowString.lowercaseString
</code></pre><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://www.dropbox.com/s/elzir5c7scwx4hb/20160901_Collection.png?dl=1" alt="1"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p>方式1</p>
<pre><code>var numbers = Array&lt;Double&gt;() //Array&lt;Double&gt;.init 后面省略了init方法
</code></pre><p>方式2</p>
<pre><code>var moreNumbers = [Double]()
moreNumbers = [85.0, 90.0, 95.0]
</code></pre><p>方式3</p>
<pre><code>let differentNumbers = [97.5, 98.5, 99.0]
</code></pre><h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><pre><code>moreNumbers = moreNumbers + differentNumbers
</code></pre><h3 id="数组可持有任何类型对象"><a href="#数组可持有任何类型对象" class="headerlink" title="数组可持有任何类型对象"></a>数组可持有任何类型对象</h3><pre><code>var circuit = [livingRoomSwitch, kitchenSwitch, bathroomSwitch]
</code></pre><h3 id="数组尾部添加"><a href="#数组尾部添加" class="headerlink" title="数组尾部添加"></a>数组尾部添加</h3><pre><code>var roadTripMusic = [&quot;Neil Young&quot;,&quot;Kendrick Lamar&quot;,&quot;Flo Rida&quot;, &quot;Nirvana&quot;]
roadTripMusic.append(&quot;Rae Sremmurd&quot;)
</code></pre><h3 id="数组插入"><a href="#数组插入" class="headerlink" title="数组插入"></a>数组插入</h3><pre><code>roadTripMusic.insert(&quot;Dej Loaf&quot;, atIndex: 2)
</code></pre><h3 id="数组删除"><a href="#数组删除" class="headerlink" title="数组删除"></a>数组删除</h3><pre><code>roadTripMusic.removeAtIndex(3)
</code></pre><h3 id="数组计数"><a href="#数组计数" class="headerlink" title="数组计数"></a>数组计数</h3><pre><code>roadTripMusic.count
</code></pre><h3 id="数组取值"><a href="#数组取值" class="headerlink" title="数组取值"></a>数组取值</h3><pre><code>let musician = roadTripMusic[2]
</code></pre><h3 id="数组替换"><a href="#数组替换" class="headerlink" title="数组替换"></a>数组替换</h3><pre><code>food[0...2] = [&quot;a&quot;,&quot;b&quot;]
//从第一个到第三个元素进行替换，但只有两个元素，第三个将被删除，被“没有”所替换
</code></pre><h3 id="数组删除最后一项"><a href="#数组删除最后一项" class="headerlink" title="数组删除最后一项"></a>数组删除最后一项</h3><pre><code>food.removeLast()
</code></pre><h3 id="数组删除所有"><a href="#数组删除所有" class="headerlink" title="数组删除所有"></a>数组删除所有</h3><pre><code>food.removeAll(keepCapacity:false)
</code></pre><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典创建"><a href="#字典创建" class="headerlink" title="字典创建"></a>字典创建</h3><p>方式1</p>
<pre><code>var groupsDict = [String:String]()
</code></pre><p>方式2</p>
<pre><code>var animalGroupsDict = [&quot;whales&quot;:&quot;pod&quot;, &quot;geese&quot;:&quot;flock&quot;, &quot;lions&quot;: &quot;pride&quot;]

var averageLifeSpanDict = [String:Range&lt;Int&gt;]()
var lifeSpanDict = [&quot;African Grey Parrot&quot;: 50...70, &quot;Tiger Salamander&quot;: 12...15, &quot;Bottlenose Dolphin&quot;: 20...30]
</code></pre><h3 id="空字典"><a href="#空字典" class="headerlink" title="空字典"></a>空字典</h3><pre><code>var emptyDic:[String:Double] = [:] 
print(emptyDic.isEmpty)
</code></pre><h3 id="字典添加"><a href="#字典添加" class="headerlink" title="字典添加"></a>字典添加</h3><pre><code>animalGroupsDict[&quot;crows&quot;] = &quot;murder&quot;
animalGroupsDict[&quot;monkeys&quot;] = &quot;troop&quot;
</code></pre><h3 id="字典计数"><a href="#字典计数" class="headerlink" title="字典计数"></a>字典计数</h3><pre><code>animalGroupsDict.count
</code></pre><h3 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h3><pre><code>animalGroupsDict[&quot;crows&quot;] = nil
</code></pre><p>移除单个值</p>
<pre><code>person.removeValueForKey(&quot;name&quot;)
</code></pre><p>移除所有值</p>
<pre><code>person.removeAll(keepCapacity:false)
</code></pre><h3 id="字典更新"><a href="#字典更新" class="headerlink" title="字典更新"></a>字典更新</h3><p>方式1</p>
<pre><code>animalGroupsDict[&quot;monkeys&quot;] = &quot;barrel&quot;
</code></pre><p>方式2:返回值为optional类型，如果该key存在，则赋新值，返回old value,如果key不存在，则赋值，同时返回nil</p>
<pre><code>var group = animalGroupsDict.updateValue(&quot;gaggle&quot;, forKey: &quot;geese&quot;)
</code></pre><h3 id="字典取值"><a href="#字典取值" class="headerlink" title="字典取值"></a>字典取值</h3><p>字典取值所返回的是optional，因为很可能没有该key，所以使用前需要用if let unwrap</p>
<pre><code>let groupOfWhales = animalGroupsDict[&quot;whales&quot;]

if let groupOfWhales = animalGroupsDict[&quot;whales&quot;] {
print(&quot;We saw a \(groupOfWhales) of whales from the boat.&quot;)
} else {
print(&quot;No value found for that key.&quot;)
}
</code></pre><h3 id="字典键和值的取出"><a href="#字典键和值的取出" class="headerlink" title="字典键和值的取出"></a>字典键和值的取出</h3><pre><code>let keysArr = [String](person.keys)
let valueArr = [String](person.values)
print(valuesArr)
</code></pre><h3 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h3><p>字典的遍历后，返回时元组类型</p>
<pre><code>for (key,value) in person{
 print(&quot;\(key):\(value)&quot;)
} 
</code></pre><h3 id="字典的使用"><a href="#字典的使用" class="headerlink" title="字典的使用"></a>字典的使用</h3><p>这种的声明是不严谨的，因为值的类型都不是一样的，系统会推断它是NSObject类型</p>
<p>字典的key or value 通常最好是同一类型，否则强制解析时会出错</p>
<pre><code>var person = [&quot;age&quot;:18,&quot;name&quot;:&quot;Tom&quot;,&quot;身高&quot;:178]
</code></pre><p>这样会报错，因为是将NSObject转为int</p>
<pre><code>var height:Int? = person[&quot;身高&quot;]  
if height != nil {
   print(height!)
}
</code></pre><p>以下才正确</p>
<pre><code>var person = [&quot;age&quot;:&quot;18&quot;,&quot;name&quot;:&quot;Tom&quot;,&quot;身高&quot;:&quot;178&quot;]

var height:String? = person[&quot;身高&quot;]  
if height != nil {
   print(height!)
}

print(person[&quot;age&quot;])
</code></pre><h2 id="Set-无序且不能有相同的元素"><a href="#Set-无序且不能有相同的元素" class="headerlink" title="Set - 无序且不能有相同的元素"></a>Set - 无序且不能有相同的元素</h2><h3 id="集合创建"><a href="#集合创建" class="headerlink" title="集合创建"></a>集合创建</h3><p>方式1</p>
<pre><code>var utensils = Set&lt;String&gt;()
var trees = Set&lt;Character&gt;()
var flowers:Set&lt;Character&gt; = [&quot;🌷&quot;,&quot;🌹&quot;,&quot;🌸&quot;]
</code></pre><p>方式2</p>
<pre><code>var cutlery: Set = [&quot;fork&quot;, &quot;knife&quot;, &quot;spoon&quot;]
</code></pre><h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><pre><code>trees.insert(&quot;🌲&quot;)
trees.insert(&quot;🌳&quot;)
trees.insert(&quot;🌵&quot;)
trees.remove(&quot;🌵&quot;)
trees.count
</code></pre><h2 id="AnyObject-and-Any"><a href="#AnyObject-and-Any" class="headerlink" title="AnyObject and Any"></a>AnyObject and Any</h2><p>Swift中有两种特殊的object:  </p>
<ol>
<li>Any:表示任何数据类型</li>
<li>AnyObject:表示任何对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    //因为数组里的数据不一样，这里的数组默认是AnyObject类型，因为他们都不一样</span><br><span class="line">    var shoppingList = [&quot;Eggs&quot;,123,true] </span><br><span class="line">    for item in shoppingList &#123;</span><br><span class="line">      print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>for fruit in food{
fruit = &quot;good&quot; //error, fruit默认是let类型
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/Swift语言基础/" itemprop="url">
                  Swift语言基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-10T16:22:51+11:00" content="2016-03-10">
              2016-03-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/10/Swift语言基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/10/Swift语言基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>let设定常量</p>
<pre><code>let encouragement = &quot;You can do it!&quot;
</code></pre><p>即使两个常量相同，也不能互相赋值</p>
<pre><code>//: ### Two ways of being immutable - #1 Assignment
var goat = UIImage(named:&quot;Chinese-New-Year-3.jpg&quot;)!
let yearsOfTheGoat = [1967, 1979, 1991, 2003, 2015]
let yearsOfTheSheep = [1967, 1979, 1991, 2003, 2015]

//以下结果会报错
yearsOfTheGoat = yearsOfTheSheep
</code></pre><p>常量不能有更改</p>
<pre><code>//以下结果会报错
yearsOfTheGoat.append(2027)
</code></pre><p>var设定变量</p>
<pre><code>var personalizedEncouragement = &quot;You can do it, Lauren!&quot;
personalizedEncouragement = personalizedEncouragement.stringByReplacingOccurrencesOfString(&quot;Lauren&quot;, withString: &quot;Cameron&quot;)  
</code></pre><p>var + 变量名 : 类型</p>
<pre><code>var age: Int  
var string: String = &quot;smile&quot;  
</code></pre><p>省略类型由系统来推断</p>
<pre><code>var a = 20, b:String, c = &quot;Swift&quot;  
</code></pre><p>标识符必须以字符(包括Unicode字符)，下划线_，美元符$开头，但不能以数字开头，不可以包含空格，不能使用关键字，其长度没有限制</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>用Int就可以了。其实还有Int16,Int32</p>
<pre><code>let oneMillion = 1_000_000 //可以增加下划线作为分隔符
print(oneMillion)
</code></pre><h2 id="整型之间转换必须是显式转换"><a href="#整型之间转换必须是显式转换" class="headerlink" title="整型之间转换必须是显式转换"></a>整型之间转换必须是显式转换</h2><pre><code>var book1: Int16 = 100
var book2: Int32 = 30
var totalPrice = Int32(book1) + book2 //必须先转换，否则会报错
</code></pre><h2 id="正无穷-负无穷-非数"><a href="#正无穷-负无穷-非数" class="headerlink" title="正无穷,负无穷,非数"></a>正无穷,负无穷,非数</h2><pre><code>var w = 4.0 / 0.0   //正无穷
var w = - 4.0 / 0.0 //负无穷
var f = 0.0 / 0.0   //非数
</code></pre><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><pre><code>var width: Float = 2.1
var height: Double = 3.9
var area1 = width * Float(height) //必须先转换，否则会报错

//在Swift2.0 版本中貌似整数不转换也可以哦
var area2 = Int(width) * 4 //必须先转换，否则会报错
</code></pre><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><pre><code>typealias Age = UInt16
let myAge:Age = 10
</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="赋值方式1-直接赋值"><a href="#赋值方式1-直接赋值" class="headerlink" title="赋值方式1.直接赋值"></a>赋值方式1.直接赋值</h3><pre><code>var score = (140,140,&quot;Good&quot;)
</code></pre><h3 id="赋值方式2-先申明类型"><a href="#赋值方式2-先申明类型" class="headerlink" title="赋值方式2.先申明类型"></a>赋值方式2.先申明类型</h3><pre><code>var health : (Int , Int , String)
health = (182 , 78 , &quot;Good&quot;)

print (&quot;health元组的值为:\(health)&quot;)  //打印元组所有
print (&quot;health元组中身高的值为:\(health.1)&quot;) //打印元组中第二个值
</code></pre><h3 id="赋值方式3-key-value赋值"><a href="#赋值方式3-key-value赋值" class="headerlink" title="赋值方式3.key-value赋值"></a>赋值方式3.key-value赋值</h3><pre><code>//顺序可以调换
var score2 = (math:140, English:140, Assessment:&quot;A&quot;)
var score3 :(math:Int, English:Int, Assessment:String)
score3 = (English:140, math:145, Assessment:&quot;A&quot;)
print(&quot;score3 中数学的成绩是: \(score3.math)&quot;)
</code></pre><h3 id="元组中的嵌套"><a href="#元组中的嵌套" class="headerlink" title="元组中的嵌套"></a>元组中的嵌套</h3><pre><code>var test:(Int,(Int,String))
test = (10,(100,&quot;Swift&quot;))
print(&quot;test元组中第二个元素的第一个元素为：\(test.1.0)&quot;)
</code></pre><h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>在swift中不能赋值nil给变量或者对象</p>
<pre><code>var x: Int
x = nil //这样赋值必报错

var c: AnyObject
c = UIColor.redColor()
c = nil //这样赋值必报错
</code></pre><p>如果遇到可能会出现nil的情况，就使用可选类型，在变量后添加?</p>
<p>情况1. 可能返回值为nil </p>
<pre><code>var y: Int?
var s1: String
var s2: String

s1 = &quot;123&quot;
s2 = &quot;ABC&quot;

y = Int(s1)
y = Int(s2)
</code></pre><p>情况2. 对象创建时属性还没赋值</p>
<pre><code>class ViewController: UIViewController {
var button: UIButton!
} 
</code></pre><p>情况3. 函数传值为nil. (在swift里，nil是个值，表示值缺失，但在OC里，nil是个空指针)</p>
<p>Example: Picking up groceries in an optional car</p>
<pre><code>func pickUpGroceries(car:Car?) {
if let car = car {
    print(&quot;We&apos;ll pick up the groceries in the \(car.make)&quot;)
} else {
    print(&quot;Let&apos;s walk to the store&quot;)
}
}

var someCar = Car(make: &quot;Toyota&quot;, model: &quot;Corolla&quot;)

pickUpGroceries(someCar)

pickUpGroceries(nil)
</code></pre><p>Example: Hosting a guest in an optional extra room</p>
<pre><code>func host(guest: String, extraRoom: Room?) {
if let extraRoom = extraRoom {
    print(&quot;Come stay with us, \(guest), you can sleep in the \(extraRoom.name).&quot;)
} else {
    print(&quot;Come stay with us, \(guest), you can sleep on the couch.&quot;)
}
}

var someRoom = Room(name: &quot;guest room&quot;, occupied: false)
host(&quot;Grandma&quot;, extraRoom: someRoom)
host(&quot;Ryan&quot;, extraRoom: nil)
</code></pre><h2 id="使用if-let强制解析-安全"><a href="#使用if-let强制解析-安全" class="headerlink" title="使用if let强制解析(安全)"></a>使用if let强制解析(安全)</h2><p>可选类型的变量就像一个盒子，里面不知道是否装着礼物。使用前必须要打开它确定是否有无，就是强制解析.</p>
<p><img src="https://www.dropbox.com/s/eh720d91kx9195q/20160831_swift1.png?dl=1" alt="1"></p>
<pre><code>var zee: Int?

let strings = [&quot;ABC&quot;,&quot;123&quot;]
let randomIndex = Int(arc4random() % 2)
let anotherString = strings[randomIndex]

zee = Int(anotherString)

if let intValue = zee {
intValue * 2
} else {
&quot;No value&quot;
}
</code></pre><p>更为便捷的命名方式,不用再重新命名</p>
<pre><code>var zee: Int?

let strings = [&quot;ABC&quot;,&quot;123&quot;]
let randomIndex = Int(arc4random() % 2)
let anotherString = strings[randomIndex]

zee = Int(anotherString)

if let zee = zee {
zee * 2
} else {
&quot;No value&quot;
}
</code></pre><h2 id="使用-强制解析"><a href="#使用-强制解析" class="headerlink" title="使用!强制解析"></a>使用!强制解析</h2><p><img src="https://www.dropbox.com/s/db06ebiosnfiqqp/20160831_swift2.png?dl=1" alt="2"></p>
<p>Example 1 - unwrap optional</p>
<p>使用!时，意味着你确定值是不为nil的，否则就会系统出错。要谨慎使用</p>
<pre><code>let w =  Int(&quot;123&quot;)!
w * 2
</code></pre><p>Example 2 - implicitly unwrap optionl</p>
<p>一开始就声明它是个需要强制解析的optionl类型，意味着使用时，它会自动unwrap</p>
<pre><code>class BetterViewController: UIViewController {
var myButton: UIButton!

override func viewDidLoad(){

super.viewDidLoad

//如果没有这行，就会报错，因为没有初始化，UIButton就是nil
button = UIButton()

var title = button.titleForState(UIControlState.Normal)

}

}
</code></pre><h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>强制解析image,获取其size属性</p>
<pre><code>var imageView = UIImageView()
imageView.image = UIImage(named:&quot;puppy_in_box&quot;)

if let image =  imageView.image {
let size = image.size
} else {
print(&quot;This image hasn&apos;t been set.&quot;)
}
</code></pre><p>使用可选链直接访问size属性</p>
<pre><code>var size = anotherImageView.image?.size
</code></pre><p>可选链unwrap image, if let unwrap size, 这样更安全</p>
<pre><code>var anotherImageView = UIImageView()
anotherImageView.image = UIImage(named:&quot;puppy_in_box&quot;)

var size = anotherImageView.image?.size

if let imageSize = anotherImageView.image?.size {

print(&quot;Here&apos;s the image size: \(imageSize)&quot;)

} else {

print(&quot;This image hasn&apos;t been set.&quot;)
}
</code></pre><p>Example 2 (传值为nil)</p>
<pre><code>var animal = Animal(name: &quot;Lenny&quot;, species: &quot;lemur&quot;, tailLength: 12)

animal = Animal(name: &quot;Gilbert&quot;, species: &quot;Gorilla&quot;, tailLength: nil )

if let tailLength = animal.tail?.length {
print(&quot;\(animal.name)&apos;s tail is \(tailLength) long&quot;)
} else {
print(&quot;\(animal.name) doesn&apos;t have a tail.&quot;)
}
</code></pre><h2 id="as-or-as-转换为子类"><a href="#as-or-as-转换为子类" class="headerlink" title="as? or as! 转换为子类"></a>as? or as! 转换为子类</h2><p>ColdDrink, HotDrink是 beverage的子类， drinkChoices是他们的集合</p>
<pre><code>for beverage in drinkChoices{

//强制解析为subclass
if let coldDrink = beverage as? ColdDrink {

    print(.....)

}else if let hotDrink = beverage as? HotDrink {

    print(.....)
}

}
</code></pre><p>如果确定的话，使用as!,就不必使用if let了</p>
<pre><code>for beverage in drinkChoices{

//强制解析为subclass
let coldDrink = beverage as！ColdDrink {

    print(.....)

}
}
</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="swift赋值"><a href="#swift赋值" class="headerlink" title="swift赋值"></a>swift赋值</h2><pre><code>var a: Int  //该表达式没有值
var b = a = 20  //不支持连续赋值
</code></pre><h2 id="求余运算"><a href="#求余运算" class="headerlink" title="求余运算"></a>求余运算</h2><pre><code>var g = 5.2 (结果正负取决于被除数的正负)
var h = 3.1
var mod = g % h
print(mod)
</code></pre><h2 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h2><h3 id="Swift1-x"><a href="#Swift1-x" class="headerlink" title="Swift1.x"></a>Swift1.x</h3><pre><code>//结果是11，先执行运算，然后a再自加1
var a = 5
var b = a++ + 6
print(b) 

//结果是12，先自身加1，再执行运算
var a = 5
var b = ++a + 6
print(b)  
</code></pre><h3 id="Swift2-x"><a href="#Swift2-x" class="headerlink" title="Swift2.x"></a>Swift2.x</h3><pre><code>a -=1
a +=1
</code></pre><h3 id="Swift3-x将取消-运算符"><a href="#Swift3-x将取消-运算符" class="headerlink" title="Swift3.x将取消 ++ 运算符"></a>Swift3.x将取消 ++ 运算符</h3><h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><pre><code>//&amp;+ &amp;- &amp;* &amp;/ &amp;% 执行的是位运算
var willUnderflow = UInt8.min //最小值是0
willUnderflow = willUnderflow &amp;-1 //下溢
</code></pre><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp; 按位与<br>|  或<br>^  异或<br>~  取反<br>&lt;&lt; 左位移<br>右位移 &gt;&gt;   </p>
<h2 id="扩展后的赋值运算符"><a href="#扩展后的赋值运算符" class="headerlink" title="扩展后的赋值运算符"></a>扩展后的赋值运算符</h2><p>-=<br>*=<br>/=<br>&amp;=<br>|=<br>运算符 “+= ” 对于 x+=y 等价于 x = x+y    </p>
<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><p>a..&lt;b (包含a,但不包含b)<br>a…b（包含a,也包含b）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a in 0..&lt;10&#123;</span><br><span class="line">print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a in 0...10&#123;</span><br><span class="line">print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较运算符，结果为BOOL值"><a href="#比较运算符，结果为BOOL值" class="headerlink" title="比较运算符，结果为BOOL值"></a>比较运算符，结果为BOOL值</h2><p>只有a和b指向的类型实例相同时，c为true</p>
<pre><code>var c= a === b 
</code></pre><ol>
<li>=== 特征相等运算符  </li>
<li>!== 特征不等运算符</li>
</ol>
<p>例子</p>
<pre><code>let ticketPrice = 7.5
let allowance = 10.0
var iceCreamPrice = 3.0

var pic = UIImage(named:&quot;Chloe.png&quot;)!

if allowance &gt;= ticketPrice + iceCreamPrice {

print(&quot;Let&apos;s go to the movies!&quot;)

} else {

print(&quot;Let&apos;s watch a movie at home and eat ice cream&quot;)

}
</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;&amp; 与<br>|| 或<br>!  非</p>
<h2 id="空合并运算符-a-b"><a href="#空合并运算符-a-b" class="headerlink" title="空合并运算符 a??b"></a>空合并运算符 a??b</h2><ol>
<li>a是可选类型，将对可选类型a进行空判断，如果a包含一个值就进行解封</li>
<li>否则就返回一个默认值b  </li>
<li>默认值b的类型必须要和a存储值的类型保持一致  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let words = &quot;hello&quot;</span><br><span class="line">var say: String? </span><br><span class="line">var content = say ?? words</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h3><p>语句的条件执行体必须放在花括号中,条件语句不用括号</p>
<pre><code>var hungry = true
var vegetarian = false

if hungry {

print(&quot;Let&apos;s eat!&quot;) 
}else{
print(&quot;Let&apos;s wait.&quot;)
}

if hungry &amp;&amp; !vegetarian {

print(&quot;Let&apos;s eat steak!&quot;)
} else if hungry &amp;&amp; vegetarian {
print(&quot;How about pumpkin curry?&quot;)
} else {
print(&quot;nevermind&quot;)
}
</code></pre><h3 id="三目运算符-Ternary-conditional"><a href="#三目运算符-Ternary-conditional" class="headerlink" title="三目运算符 - Ternary conditional"></a>三目运算符 - Ternary conditional</h3><p>以下两种写法相等</p>
<pre><code>if question { answer1 } else { answer2 }

question ? answer1 : answer2
</code></pre><p>例子1.</p>
<pre><code>hungry ? print(&quot;Let&apos;s eat!&quot;) : print(&quot;Let&apos;s wait.&quot;)
</code></pre><p>例子2.</p>
<pre><code>hungry || thereIsPie ? print(&quot;Let&apos;s eat!&quot;) : print(&quot;Let&apos;s wait.&quot;)
</code></pre><p>例子3.</p>
<pre><code>// Ternary statements can also be used as expressions.
let sandwichPrice = 5.0
var tax = true
var lunchPrice = sandwichPrice + (tax ? 0.50 : 0)
</code></pre><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch -"></a>Switch -</h3><p>格式：case后可以有多个值，每条语句执行完后自动退出</p>
<pre><code>switch variable {
case firstValue:
statement
case secondValue:
statement
case thirdValue, fourthValue:
statement
default:
statement 
}
</code></pre><p>case后可以是个范围</p>
<pre><code>var color = &quot;&quot;
var wavelength = 568

switch wavelength {
case 380...450:
color = &quot;violet&quot;
case 451...495:
color = &quot;blue&quot;
case 496...570:
color = &quot;green&quot;
case 571...590:
color = &quot;yellow&quot;
case 591...620:
color = &quot;orange&quot;
case 621...750:
color = &quot;red&quot;
default:
color = &quot;not visible&quot;
}
</code></pre><p>case后的条件为元组</p>
<pre><code>var point = (x:5 , y:2)

switch point {
case (0,0):
    print(&quot;(0,0)位于原点&quot;)
case (_,0):   //用 &quot;_&quot; 表示可以忽略这个数据
    print(&quot;(\(point.0),0)位于x轴上&quot;)
case (0...Int.max as ClosedInterval, 0...Int.max as ClosedInterval):
    print(&quot;(\(point.0),\(point.1))位于第一象限&quot;)
default:
    break
}
</code></pre><p>使用fallthrough语句才能贯穿，否则不再继续执行下一条</p>
<pre><code>    var num = 5
    var desc = &quot;\(num)是&quot;
    switch num {
    case 2, 3, 5, 7 :
     desc += &quot;质数，而且还是&quot;
     fallthrough
default:
     desc += &quot;整数&quot;
}
print(desc) //结果是“5是质数，而且还是整数”
</code></pre><p>支持值绑定</p>
<pre><code>var point = (x:1 , y:1)
switch point {
case (0,0):
   print(&quot;(0,0)位于原点&quot;)
case (var a, 0)://y坐标为0，进入该case块，并将元组的x成员绑定到临时变量a
   print(&quot;该点位于x轴上，x值为:\(a)&quot;)
case var (x,y) where x&gt;0 &amp;&amp; y&gt;0:  //条件值绑定
   print(&quot;(\(x),\(y))位于第一象限&quot;)
default:
   break
}
</code></pre><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><p>传统的C - style for loop （swift也支持）</p>
<pre><code>for var index = 99; index &gt;0; --index {

print (&quot;Hello&quot;) 

}
</code></pre><p>更为简洁的形式 </p>
<pre><code>for item in Collection {
statements to execute on each item
}
</code></pre><p>例子1 </p>
<pre><code>for index in 1...5 {
print(&quot;\(index) times 5 is \(index * 5)&quot;)
}
</code></pre><p>例子2 不访问index的值</p>
<pre><code>let base = 3
let power = 10
var answer = 1
for _ in 1...power { //下划线符号_替代循环中的变量，能够忽略具体的值，并且不提供循环遍历时对值的访问
  answer *= base
}
</code></pre><p>例子3 遍历数组累加</p>
<pre><code>let intArray = [7, 21, 25, 13, 1]
var sum = 0
for value in intArray {
sum += value
}
</code></pre><p>例子4 遍历字典value值替换key值</p>
<pre><code> for (key, value) in Dictionary {

 statement to execute on each key or value

 }    


let dictionary = [&quot;monkey&quot;: &quot;🐒&quot;, &quot;iPhone&quot;:&quot;📱&quot;]
var newestString = sillyMonkeyString

for (key, value) in dictionary {
newestString = newestString.stringByReplacingOccurrencesOfString(key, withString: value)
}

print(newestString)
</code></pre><h3 id="嵌套循环遍历时使用的标签"><a href="#嵌套循环遍历时使用的标签" class="headerlink" title="嵌套循环遍历时使用的标签"></a>嵌套循环遍历时使用的标签</h3><ol>
<li>紧跟冒号的标识符，只有放在循环语句或者switch语句之前才有作用</li>
<li>break结束循环，开始执行循环之后的代码</li>
<li>continue 忽略本次循环的剩下语句，执行下一次循环，但不终止循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">outer: for i in 0...5 &#123;</span><br><span class="line">    //内层循环</span><br><span class="line">    for j in 0...3&#123;</span><br><span class="line">    print(&quot;i的值为:\(i),j的值为\(j)&quot;)</span><br><span class="line">    if j==1 &#123;</span><br><span class="line">    break outer</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while-…-loop"><a href="#while-…-loop" class="headerlink" title="while … loop"></a>while … loop</h3><pre><code>while condition {
statement
}


var timer = 10

while timer &gt; 0 {
timer -= 1
}
</code></pre><h3 id="repeat-…-loop"><a href="#repeat-…-loop" class="headerlink" title="repeat … loop"></a>repeat … loop</h3><pre><code>repeat {
statement
} while condition


repeat {
 --timer
} while timer &gt; 0
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Jack Liu" />
          <p class="site-author-name" itemprop="name">Jack Liu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">102</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Liu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'cowboyTech';
      var disqus_identifier = 'page/20/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  
  

  
  


</body>
</html>
