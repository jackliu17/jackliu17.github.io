<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="D3Af5_wNyfCxpGOmu04o8yJ6Y4au_48rBuja2NxHLOs" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Cowboy Tech" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Cowboy Tech">
<meta property="og:url" content="http://jackliu17.github.io/index.html">
<meta property="og:site_name" content="Cowboy Tech">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cowboy Tech">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Cowboy Tech </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Cowboy Tech</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">go go go!</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      


      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/Swift面向对象基础（中）/" itemprop="url">
                  Swift面向对象基础（中）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-12T12:04:36+11:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/12/Swift面向对象基础（中）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/12/Swift面向对象基础（中）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="存储属性和计算属性"><a href="#存储属性和计算属性" class="headerlink" title="存储属性和计算属性"></a>存储属性和计算属性</h1><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ol>
<li>存储在类，结构体里的变量或者常量</li>
<li>实例存储属性：单个实例的状态数据。类型存储属性：类，结构体，枚举</li>
<li>所有的存储属性必须显式的指定初始值，在定义时或者构造器当中指定</li>
<li>可选类型的存储属性可以不指定初始值</li>
</ol>
<h2 id="结构体中实例存储属性的规则"><a href="#结构体中实例存储属性的规则" class="headerlink" title="结构体中实例存储属性的规则"></a>结构体中实例存储属性的规则</h2><pre><code>struct LengthRange {
var start: Int
//定义常量存储属性，可以不指定初始值
let length:Int
}

var len = LengthRange(start:9, length:3)
//通过构造器参数完成实例存储属性的初始化
println(&quot;len的起点为\(en.start),长度为\(en.length)&quot;)


len.start = 2
len.length = 4 //这个会报错，因为是常量，常量是不能修改的
</code></pre><ol>
<li>程序为所有的实例存储属性指定了初始值，且没有构造器，则系统会提供两个构造器：一个无参数的构造器和一个初始化所有实例存储属性的构造器。</li>
<li>没有初始值和构造器，系统提供一个初始化所有实例存储属性的构造器。   </li>
<li>有构造器，则程序必须为结构体中的所有存储属性提供初始值。</li>
</ol>
<h2 id="结构体常量与实例属性"><a href="#结构体常量与实例属性" class="headerlink" title="结构体常量与实例属性"></a>结构体常量与实例属性</h2><pre><code>struct LengthRange2{
var start: Int
var length:Int
}

let len2 = LengthRange(start:1, length:5)
</code></pre><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><p>第一次被调用时才会被计算初始值的属性，用lazy修饰符</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>[修饰符]var计算属性名:属性类型{
get{
//get方法执行体，该方法一定要有返回值
}

set(形参名){
setter方法执行体，该方法一定不能有返回值
}

}
</code></pre><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><pre><code>class User{
var first:String = &quot;&quot;
var last:String = &quot;&quot;

//定义计算属性
var fullName:String{

//定义计算属性的getter方法，该方法的返回值由first,last两个存储属性决定
gett{
   return first + &quot;-&quot; + last
}

//定义计算属性的setter方法
//该setter方法将负责改变该实例的first,last两个存储属性
set (newValue){
  var names = newValue.componentsSeparateByString(&quot;-&quot;)
  self.first = names[0]
  self.last = names [1]
}

}

init(first:String, last:String){
   self.first = first
   self.last = last
}

}


let s = User(first:&quot;极客&quot;，last:&quot;Hello&quot;)
println(s.fullName) //结果是：极客-Hello


s.fullName = &quot;极客-学院&quot;
println(s.first)  //outcome is 极客
println(s.last)   //结果是 学院
</code></pre><h3 id="例子2-只读属性"><a href="#例子2-只读属性" class="headerlink" title="例子2 只读属性"></a>例子2 只读属性</h3><p>无需set部分，可以省略get和花括号</p>
<pre><code>class User{
var first:String = &quot;&quot;
var last:String = &quot;&quot;

//定义计算属性
var fullName:String{

//定义计算属性的getter方法，该方法的返回值由first,last两个存储属性决定
   return first + &quot;-&quot; + last

}

init(first:String, last:String){
   self.first = first
   self.last = last
}

}
</code></pre><h2 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>[修饰符]var 计算属性名：属性类型 = 初始值 {
  willSet (newValue){
  //属性即将被赋值之前自动调用的方法

  }

  didSet(oldValue){
  //属性被赋值完成之后自动调用的方法

  }
}
</code></pre><p>注意：willSet和didSet后面的参数名都可以身略</p>
<ol>
<li>除了延迟存储属性之外的所有存储属性（包括实例存储属性和类型存储属性）</li>
<li>可通过重载方式为继承得到的属性（包括存储属性和计算属性）添加属性观察者。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>class Person {
  //定义存储属性
  var name: String = &quot;&quot;{
    willSet{
      if(countElements(newValue)&gt;6)||(countElements(newValue)&lt;2){
        println(&quot;您设置的人名\(newValue)不符合要求，请重新设置！&quot;)
      }else{
        println(&quot;人名设置符合要求，设置成功&quot;)
      }
    }

    didSet{
        println(&quot;人名设置完成，被修改的原名为：\(oldValue)&quot;)
    }
  }

  var age: Int = 0{

      willSet{

        if newValue&gt;100 || newValue &lt;0{

           println(&quot;您设置的年龄\(newValue)不符合要求，请重新设置！&quot;)

        }else{

           println(&quot;年龄设置符合要求，设置成功&quot;)

        }
      }

      didSet {

           println(&quot;年龄设置完成，被修改的年龄为：\(oldValue)&quot;)

      }
  }
}

var p = Person()
p.age = 999  //不成功的设置
p.age = 10 // 成功的设置
</code></pre><h1 id="Swift中的方法"><a href="#Swift中的方法" class="headerlink" title="Swift中的方法"></a>Swift中的方法</h1><h2 id="方法的所属性"><a href="#方法的所属性" class="headerlink" title="方法的所属性"></a>方法的所属性</h2><ol>
<li>定义方法需要在类型（枚举，结构体，类）里下定义，不能独立定义</li>
<li>方法要么属于该类型本身，要么是该类型的一个实例</li>
<li>不能独立执行方法，执行方法必须使用类型或实例作为调用者</li>
<li>枚举，结构体中方法使用static修饰，类中用class修饰，都属于类型方法，否则的话属于实例方法</li>
</ol>
<h2 id="将方法转换为函数"><a href="#将方法转换为函数" class="headerlink" title="将方法转换为函数"></a>将方法转换为函数</h2><pre><code>class SomeClass {

func test() {
  println(&quot;==test 方法==&quot;)
}

class func bar(#msg:String) {
  println(&quot;==bar类型方法==，传入的参数为:\(msg)&quot;)
}
}

var sc = SomeClass()     //创建实例
var f1:()-&gt;()=sc.test    //将sc的test方法分离成函数

var f2:(String) -&gt; Void = SomeClass.bar    //将sc的bar方法分离成函数
f1()    //等价于sc.test()
f2(&quot;极客&quot;)  //等价于SomeClass.bar(msg:&quot;Geek&quot;)
</code></pre><h2 id="方法的外部形参名"><a href="#方法的外部形参名" class="headerlink" title="方法的外部形参名"></a>方法的外部形参名</h2><p>默认除第一个参数外都添加了外部参数名，与局部参数名一样，如果不需要的话，则用_下划线的方式去掉</p>
<pre><code>class Person {

   var name:String

   init(name:String){

     self.name = name

   }

   func eat (food:String, _drink:String, cigarette:String){

     println(&quot;\(self.name)吃着\(food),喝着\(drink),抽着\(cigarette)&quot;)

   }
}

var p = Person(name:&quot;Tom&quot;)
p.eat(&quot;烤鸭&quot;，“啤酒”，cigarette:&quot;雪茄&quot;)
</code></pre><h2 id="值类型的可变方法"><a href="#值类型的可变方法" class="headerlink" title="值类型的可变方法"></a>值类型的可变方法</h2><pre><code>struct JKRect {
  var x: Int
  var y: Int
  var width:Int
  var height:Int
  mutating func moveByX(x:Int,y:Int){
    self.x += x
    self.y += y
  }
}

var rect = JKRect(x:20, y:12, width:200, height:300)   //创建实例
rect.moveByX(100, y:90)   //调用mutating方法，该方法可以改变rect实例的存储属性
println(“rect矩形的左上角的x坐标为：\(rect.x),y坐标为:\(rect.y)”)
</code></pre><ol>
<li>将mutating关键字放在func之前，即将该方法声明为可变方法</li>
<li>常量类型的结构体，枚举是不可变的</li>
</ol>
<h1 id="属性和方法的统一"><a href="#属性和方法的统一" class="headerlink" title="属性和方法的统一"></a>属性和方法的统一</h1><p>使用函数类型定义存储属性，并将函数或者闭包作为该属性的初始值，这个属性就成了方法</p>
<pre><code>func factorial(n:Int) -&gt; Int {
var result = 1
for i in 1...n {
   result *= i
}
return result 
}

struct SomeStruct {
var info:() -&gt; Void = {
  println(&quot;info方法&quot;)
}

//将全局函数作为fact存储属性的初始值
static var fact:(Int) -&gt; Int = factorial
}

var sc = SomeStruct()
//调用info方法
sc.info()  //outcome is info方法

//使用闭包对sc对象的info赋值，相当于重新定义sc的info方法
sc.info = {
  println(&quot;另外一个闭包&quot;)
}

sc.info()  //outcome is 另外一个闭包

var n = 6

//调用fact方法，执行的是阶乘 
println(&quot;\(n)的阶乘是：\(SomeStruct.fact(6))&quot;) //Outcome is 720

//使用闭包对SomeStruct的fact赋值，相当于重新定义SomeStruct的fact方法

SomeStruct.fact = {
  var result = 1
  for i in 1...$0 {
     result += i
  }
  return result
}

//再次调用fact方法，执行的是累加
println(&quot;\(n)的累加的和是:\(SomeStruct.fact(6))&quot;) //outcome is 22
</code></pre><h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><ol>
<li>所有的Swift类型（枚举，类，结构体）都支持定义下标</li>
<li>同一个类型可以定义多个下标</li>
<li>通过下标的形参列表或者返回值类型来区分不同的下标</li>
<li>同一类型中定义多个不同的下标被称为下标重载</li>
</ol>
<h2 id="下标的基本用法"><a href="#下标的基本用法" class="headerlink" title="下标的基本用法"></a>下标的基本用法</h2><pre><code>Subscripe(形参列表) -&gt;下标返回值类型 {

get {
  //getter方法执行体，该方法必须有返回值
}

set(形参名){
  //setter方法执行体，该方法不能有返回值
}
}
</code></pre><h2 id="下标语法格式说明"><a href="#下标语法格式说明" class="headerlink" title="下标语法格式说明"></a>下标语法格式说明</h2><ol>
<li>形参列表：与函数的形参列表的用法基本相同，但是不支持指定外部参数和默认值</li>
<li>下标的返回值类型：可以是任何有效的类型</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>struct JKRect2{
  var x:Int
  var y:Int
  var width:Int
  var height:Int

  //定义下标，指定下标只接受一个Int类型的参数，下标的返回类型为Int

  subscript(index:Int) -&gt;Int {

    get{
        switch(index){
        case 0:
           return self.x
        case 1:
           return self.y
        case 2:
           return self.width
        case 3:
           return self.height
        default:
           println(&quot;不支持该索引值&quot;)
           return 0
        }
    }

    set{
         switch(index){
         case 0:
            self.x = newValue
         case 1:
            self.y = newValue
         case 2:
            self.width = newValue
         case 3:
            self.height = newValue
         default:
            println(&quot;不支持该索引值&quot;)
         }
    }
  }
}

//创建实例
var rect2 = JKRect2(x:20,y:12,width:200,height:300)

//通过下标进行赋值
rect2[0] = 40
rect2[1] = 67

//通过下标访问rect的属性
println(&quot;rect2矩形的左上角的x坐标为:\(rect2[0]),y坐标为:\(rect2[1])&quot;)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/Swift面向对象基础(上)/" itemprop="url">
                  Swift面向对象基础(上)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-11T18:06:33+11:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/11/Swift面向对象基础(上)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/11/Swift面向对象基础(上)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h1><ol>
<li>面向对象的核心：类和对象</li>
<li>面向对象编程的三大特征：封装，继承，和多态</li>
<li>Swift可以定义枚举，结构体，和类三种面向对象的类型</li>
<li>支持定义存储属性，计算属性，方法，下标，构造器和嵌套类型</li>
</ol>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举定义"><a href="#枚举定义" class="headerlink" title="枚举定义"></a>枚举定义</h2><ol>
<li>用于管理一组有限的值的集合</li>
<li>支持计算属性</li>
<li>支持实例方法和类方法</li>
<li>支持定义构造器来完成初始化</li>
<li>支持扩展和协议</li>
</ol>
<h2 id="枚举语法"><a href="#枚举语法" class="headerlink" title="枚举语法"></a>枚举语法</h2><p>enum 枚举名 {<br>  //使用case关键字列出所有枚举值<br>  //枚举的其他成员</p>
<p>}</p>
<h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><pre><code>//方法1
enum Season {
   case Spring
   case Summer
   case Fall
   case Winter
}

//方法2
enum Season2 {
   case Spring, Summer, Fall, Winter
}
</code></pre><h2 id="使用枚举声明变量"><a href="#使用枚举声明变量" class="headerlink" title="使用枚举声明变量"></a>使用枚举声明变量</h2><pre><code>var weather: Season
weather = .Summer
println(weather)
</code></pre><h2 id="枚举值和switch语句"><a href="#枚举值和switch语句" class="headerlink" title="枚举值和switch语句"></a>枚举值和switch语句</h2><p>switch中的case没有覆盖枚举的所有值，必须添加default语句</p>
<pre><code>var chooseDay = Season.Fall

switch(chooseDay){
case .Spring:
  println(&quot;This is spring&quot;)
case .Summer:
  println(&quot;This is summer&quot;)

default:
  println(&quot;At home&quot;)

}
</code></pre><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><p>enum 枚举名：原始值类型{<br>   case 枚举值 = 原始值<br>}</p>
<h3 id="整型的枚举"><a href="#整型的枚举" class="headerlink" title="整型的枚举"></a>整型的枚举</h3><pre><code>//可以自动推断，不用每个都赋予原始值
enum Weekday: Int{
  case Mon, Tur, Wen = 3, Thur, Fri, Sat , Sun

}
</code></pre><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><pre><code>//必须每个都赋予原始值，因为不能自动推断
enum Season3: Character{
  case Spring = &quot;春天&quot;
  case Summer = &quot;夏天&quot;
  case Fall = &quot;秋天&quot;
  case Winter = &quot;冬天&quot;
}
</code></pre><h3 id="获取原始值"><a href="#获取原始值" class="headerlink" title="获取原始值"></a>获取原始值</h3><pre><code>println(Weekday.Fri.rawvalue)
</code></pre><h3 id="获取枚举值"><a href="#获取枚举值" class="headerlink" title="获取枚举值"></a>获取枚举值</h3><pre><code>var mySeason = Season3(rawValue:&quot;春天&quot;)
if mySeason != nil {
  switch(mySeason!){ //不为空才能进行强制解析
  case .Spring:
    println(&quot;春天不是读书天&quot;)
  case .Summer:
    println(&quot;夏天炎炎正好眠&quot;)
  case .Fall , .Winter:
    println(&quot;秋多蚊蝇冬日冷&quot;)
  default:
    println(&quot;读书只好等明年&quot;)

  }
}
</code></pre><h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><pre><code>enum Planet {
case Earth(weight: Double , name:String)
case Mars (density: Double, name: String, weight:Double)
case Venus(Double, String)
case Saturn
case Neptune
}

var p1 = Planet.Earth(weight:1.0, name:&quot;地球&quot;)
var p2 = Planet.Venus(0.815,&quot;金星&quot;)
var p3 = Planet.Mars(density:3.95, name:&quot;火星&quot;,weight:0.1)

switch (p3){
//将关联值绑定到变量或者常量来提取
case Planet.Earth(var weight , var name):
   println(&quot;此行星的名字为:\(name),质量相当于\(weight)个地球&quot;)

//将关联值都提取为常量或者变量，只将一个var或者let放在枚举成员之前
case let Planet.Mars(density:d, name:n, weight:w):
   println(&quot;此行星的名字为:\(n),质量相当于\(w)个地球，密度为\(d)&quot;)
default:
   break
}
</code></pre><h1 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h1><ol>
<li>这两个非常相似</li>
<li>主要区别在于结构体和枚举不支持继承，只有类才有继承</li>
<li>结构体和枚举是值类型</li>
<li>类是引用类型</li>
<li>只有类的实例可以称为对象</li>
</ol>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code>[修饰符]class类名 {
零到多个构造器
零到多个属性
零到多个方法
零到多个下标
}
修饰符可以是private ,public, internal,final

class Person {
var name: String = &quot;Jack&quot;
var age: Int = 0
func say(content: String)
{
   println(content)
}
}
</code></pre><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><pre><code>[修饰符]struct 结构体名 {

}
修饰符可以是private , public, internal

struct Dog{

var name: String
var age: Int
func run(){

println(&quot;\(name)在奔跑&quot;)
}
}
</code></pre><h3 id="定义属性的语法"><a href="#定义属性的语法" class="headerlink" title="定义属性的语法"></a>定义属性的语法</h3><pre><code>[修饰符]var或者let 存储属性:类型名字 = 初始值
</code></pre><h3 id="定义构造器语法"><a href="#定义构造器语法" class="headerlink" title="定义构造器语法"></a>定义构造器语法</h3><pre><code>[修饰符]init(形参列表){
//零到多条可执行语句组成的构造器执行体
}
</code></pre><h3 id="定义方法的语法"><a href="#定义方法的语法" class="headerlink" title="定义方法的语法"></a>定义方法的语法</h3><pre><code>[修饰符]func 方法名(形参列表) -&gt;返回值类型 {
//零到多条可执行语句
}
</code></pre><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><pre><code>var p: Person
p = Person() //等价于 var p = Person()
println(p.name)
p.say(“Hello world”)
</code></pre><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><pre><code>var dog = Dog(name:&quot;Wangcai&quot;, age:2)
println(dog.name)
dog.run()
</code></pre><h2 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h2><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><pre><code>var p2 =p
p2.name = &quot;Rose&quot;
println(p.name)
</code></pre><ol>
<li>内存里的对象可以有多个引用，即多个引用变量指向同一个对象</li>
<li>如果一个引用更改了，那对象里的值也会更改。</li>
</ol>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><pre><code>var dog2 = dog
dog2.name = &quot;snoopy&quot;
println(dog2.name)
println(dog.name)
</code></pre><ol>
<li>值对象是要复制的</li>
<li>每个值对象的更改，不会影响其他对象的更改</li>
<li>因此枚举和结构体是没有继承的  </li>
</ol>
<h3 id="引用类型的比较"><a href="#引用类型的比较" class="headerlink" title="引用类型的比较"></a>引用类型的比较</h3><pre><code>class User {
var name: String
var age: Int
init(name: String, age: Int){
  self.name = name
  self.age = age
}
}

var u1 = User(name:&quot;Han&quot;,age:32)
var U2 = User(name:&quot;Han&quot;,age:32)
//虽然传递的值是一样，但是是创建了两个对象

println(u1===u2) //u1与u2引用的不是同一对象,结果是false
println(u1!==u2) //结果是true

var u3 = u1
println(u3===u1) //结果是true
</code></pre><ul>
<li>=== 这个不能用于值类型的判断</li>
</ul>
<h3 id="self关键字"><a href="#self关键字" class="headerlink" title="self关键字"></a>self关键字</h3><h4 id="方法中的self代表该方法的调用者"><a href="#方法中的self代表该方法的调用者" class="headerlink" title="方法中的self代表该方法的调用者"></a>方法中的self代表该方法的调用者</h4><pre><code>class Dog {  
  func jump(){
    println(&quot;正在执行jump方法&quot;)
  }
  func run(){
  self.jump()
     println(&quot;正在执行run方法&quot;)
  }
}
</code></pre><h4 id="构造器中的self代表该构造器正在初始化的实例"><a href="#构造器中的self代表该构造器正在初始化的实例" class="headerlink" title="构造器中的self代表该构造器正在初始化的实例"></a>构造器中的self代表该构造器正在初始化的实例</h4><pre><code>class Person {
    var name: String = &quot;&quot;
    var age: Int = 2

    init(name:String, age:Int){
    self.name = name
    self.age = age
    }

    func info(){
    println(“我的名字是:\(name)年龄是:\(age)”)
    }
}

var person = Person(name:&quot;Lily&quot;,age:10)
person.info()
</code></pre><h3 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h3><ol>
<li>结构体的主要目的是用于封装少量相关的简单数据</li>
<li>如果需要在传递参数或者赋值时自动复制副本，使用结构体</li>
<li>明确该类型无须继承另一个已有的类或被其他类继承</li>
<li>注意，大部分时候，程序应该自定义类而不是自定义结构体。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/Swift中的函数和闭包/" itemprop="url">
                  Swift中的函数和闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-11T12:38:16+11:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/11/Swift中的函数和闭包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/11/Swift中的函数和闭包/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h2><p>fun 函数名（形参列表）-&gt; 返回值类型 {<br>//可执行语句组成的函数<br>}</p>
<h3 id="两个参数"><a href="#两个参数" class="headerlink" title="两个参数"></a>两个参数</h3><pre><code>func sayHello(personName:String)-&gt; String {

  return &quot;Hello ,&quot; + personName + &quot;!&quot;
}

println(sayHello(&quot;Anna&quot;))
</code></pre><h3 id="没有参数"><a href="#没有参数" class="headerlink" title="没有参数"></a>没有参数</h3><pre><code>func sayHellloWorld() -&gt; String{

return &quot;Hello world!&quot;
}
</code></pre><h2 id="函数形参和实参"><a href="#函数形参和实参" class="headerlink" title="函数形参和实参"></a>函数形参和实参</h2><pre><code>func max(x:Int, y:Int)-&gt;Int { //这里的xy就是形参

return x&gt;y ? x:y  

}

println(max(3,5)) //这里的3，5是实参
</code></pre><h3 id="局部参数"><a href="#局部参数" class="headerlink" title="局部参数"></a>局部参数</h3><p>width,height 不能在调用函数时使用，这是局部参数</p>
<pre><code>func area(width:Double, height:Double)-&gt;Double{

return width * height     
}

println(4.5,3.4) //不能传入width, height
</code></pre><h3 id="外部参数名"><a href="#外部参数名" class="headerlink" title="外部参数名"></a>外部参数名</h3><pre><code>func area (宽 width:Double ,高 height:Double ) -&gt;Double {

return width * height
}

println (area(宽:3.4,高:4.7)) //宽和高为外部函数名
</code></pre><h3 id="以-代替外部参数名"><a href="#以-代替外部参数名" class="headerlink" title="以#代替外部参数名"></a>以#代替外部参数名</h3><p>如果外部参数名和局部参数一样的话，只需要在局部参数前加 #</p>
<pre><code>func area (#width:Double ,#height:Double ) -&gt;Double {

return width * height
}

println (area(width:3.4,height:4.7)) //width和height为外部函数名
</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func sum(numbers:Int...)-&gt;Int &#123;</span><br><span class="line">var total: Int = 0</span><br><span class="line">for num in numbers &#123;</span><br><span class="line">   total += num</span><br><span class="line">&#125;</span><br><span class="line">println(total)</span><br><span class="line">return total</span><br><span class="line">&#125;</span><br><span class="line">sum(1,3,4,5)</span><br></pre></td></tr></table></figure>
<ol>
<li>在参数类型后面添加…表示该参数可以接受多个参数值</li>
<li>一个函数当中只有一个可变参数,并且位于列表的最后</li>
</ol>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> func sayHi(msg:String, name:String=&quot;Lily&quot;)&#123;</span><br><span class="line"> println (&quot;\(name),\(msg)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">sayHi(&quot;Welcome to our city&quot;) //目前只传入了一个参数，如果第二个参数没传入，就使用默认值</span><br><span class="line">sayHi(&quot;Welcome to our city&quot;, name:&quot;Tom&quot;) //如果传入了，就使用传入的新值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//忽略默认值的外部参数名，添加下划线</span><br><span class="line">     func sayHi(msg:String, _name:String=&quot;Lily&quot;)&#123; </span><br><span class="line">      println (&quot;\(name),\(msg)&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">     sayHi(&quot;Welcome to our city&quot;,&quot;Tom&quot;)</span><br></pre></td></tr></table></figure>
<ol>
<li>带有默认值的参数是有外部参数名的</li>
<li>添加下划线就可以忽略</li>
<li>如果函数里有可变参数也有默认参数，可变参数放在最后面，默认参数出现在次后面</li>
</ol>
<h3 id="常量形参数和变量形参"><a href="#常量形参数和变量形参" class="headerlink" title="常量形参数和变量形参"></a>常量形参数和变量形参</h3><pre><code>//这里的形参是个变量，如果去掉var就是个常量
func factorial(var number:Int) -&gt; Int{
var result:Int = 1
while number &gt; 1 {
  result = result * number
  number--
}
return result
}
println(factorial(3))
</code></pre><h3 id="In-out形参"><a href="#In-out形参" class="headerlink" title="In-out形参"></a>In-out形参</h3><pre><code>func swap (inout a:Int, inout b:Int){
let tmp = a
a = b
b = tmp
}

var a:Int = 1
var b:Int = 3
swap(&amp;a,&amp;b)
println(“交换之后结果为:a =\(a),b= \(b)”)
</code></pre><ol>
<li>In-out参数就是强制传递变量的指针</li>
<li>只能传入变量作为实参</li>
<li>输入输出不能带有默认值</li>
<li>如果你用关键字inout标记了一个参数，这个参数不能再用var或者let去标记</li>
</ol>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>没有指定返回类型的函数总返回void,在swift中，void可以理解为空元组</p>
<pre><code>func sayHi2(){
println(&quot;welcome&quot;)
}
sayHi2()
</code></pre><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><pre><code>func area(width:Double,height:Double)-&gt;(Double,Double){
var s = width * height
var c = (width + height) * 2
return (s,c)
}
println(area(3.1, 3.4))
</code></pre><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h3><pre><code>func addTwoInts(a:Int,b:Int)-&gt;Int{

return a+b
}

func multiplyTwoInts(a:Int,b:Int)-&gt;Int{

return a*b
}

var mathFunction:(Int,Int) -&gt; Int = multiplyTwoInts
println(&quot;Result:\(mathFunction(2,3))&quot;)
</code></pre><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><pre><code>func printMathResult(mathFunctioin:(Int,Int)-&gt;Int,a:Int,b:Int){

println(&quot;Result:\(mathFunction(a,b))&quot;)
}

printMathResult(multiplyTwoInts,3,5)
</code></pre><h3 id="函数类型作为返回值类型"><a href="#函数类型作为返回值类型" class="headerlink" title="函数类型作为返回值类型"></a>函数类型作为返回值类型</h3><pre><code>func squre(num:Int) -&gt;Int{

return num * num
}

func cube(num:Int) -&gt;Int{

return num * num * num
}

func getMathFunc (#type: String)-&gt; (Int) -&gt;Int {
switch (type){
   case &quot;squre&quot;:
   return squre
default:
   return cube
}
}

var mathFunc = getMathFunc(type:&quot;other&quot;)
println(mathFunc(5))
</code></pre><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>形参和返回值不一样的同名函数</p>
<pre><code>//1.
func test(){
println(&quot;无参数的test()函数&quot;)
}

//2.
func test (msg: String){
println(&quot;重载的test()函数\(msg)&quot;)
}

//3.
func test(msg: String) -&gt; String {
println(&quot;重载的test()函数\(msg),带返回值&quot;)
return &quot;test&quot;
}

//4.
func test(#msg: String){
  println (&quot;重载的test函数，外部参数为\(msg)&quot;)
}

//调用1
test()

//调用4
var result:Void = test(msg:&quot;Jike&quot;)

//调用3
var result2: String = test(&quot;Welcome , Geek&quot;)
</code></pre><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>函数体内部所定义的函数</p>
<pre><code>func getMathFunc(#type: String) -&gt; (Int) -&gt;Int{

func squre (num:Int) -&gt; Int{

return num * num
}

func cube (num:Int) -&gt;Int{

return num * num * num
}

switch(type){

   case &quot;squre&quot;
   return squre
default:
   return cube
}

}

var mathFunc = getMathFunc (type:&quot;squre&quot;)
println(mathFunc(4)) //outcome is 16

var mathFunc2 = getMathFunc (type:&quot;other&quot;)
println(mathFunc(4)) //outcome is 64
</code></pre><h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><h2 id="闭包的写法"><a href="#闭包的写法" class="headerlink" title="闭包的写法"></a>闭包的写法</h2><p>{ （形参列表）-&gt; 返回值类型 in<br>   可执行表达式<br>}</p>
<pre><code>func getMathFunc(#type: String) -&gt; (Int) -&gt;Int{

func squre (num:Int) -&gt; Int{

return num * num
}

func cube (num:Int) -&gt;Int{

return num * num * num
}

switch(type){

   case &quot;squre&quot;
   return { (num: Int) -&gt; Int in
      return num * num
   }
default:
   return { (num:Int) -&gt; Int in
      return num * num * num

   }
}

}
</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><pre><code>var mathFunc = getMathFunc(type: &quot;squre&quot;)
println(mathFunc(5)) //outcome is 25
mathFunc = getMathFunc (type: &quot;other&quot;)
println(mathFunc(5)) //outcome is 125
</code></pre><h2 id="利用上下文推断类型"><a href="#利用上下文推断类型" class="headerlink" title="利用上下文推断类型"></a>利用上下文推断类型</h2><p>Swift可以推断闭包的形参类型和返回值类型<br>函数和闭包是统一的</p>
<pre><code>var squre:(Int) -&gt; Int = {(num) in return num * num}
println(squre(3))   //outcome is 9

//因为可以推断，所以小括号也是可以省略的
var squre:(Int) -&gt; Int = {num in return num * num}
println(squre(3))   //outcome is 9

//省略形参名，通过$0,$1...来引用第一个，第二个参数
var squre:(Int) -&gt; Int = {$0 * $0}
println(squre(3))  //out come is 9

var result: Int = {

var result = 1
for i in 1...$1{
   result *= $0
}
return result
}(4,3)
println(result) //outcome is 64
</code></pre><h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><pre><code>func someFunction(num:Int, fn:(Int) -&gt;()){

}

someFunctioin (20,{})

//使用尾随闭包调用函数的格式，将小括号提前
someFunction(20){}
</code></pre><h2 id="捕获上下文中的变量或者常量"><a href="#捕获上下文中的变量或者常量" class="headerlink" title="捕获上下文中的变量或者常量"></a>捕获上下文中的变量或者常量</h2><p>闭包可以访问或者修改其所在上下文中的变量或常量</p>
<pre><code>func makeArr(ele:String) -&gt; () -&gt; [String]{

//创建一个不包含任何元素的数组
var arr: [String] = []
func addElement() -&gt;[String]{

//向arr数组中添加一个元素
arr.append(ele)

return arr
}

return addElement
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/Swift中的字符串和集合/" itemprop="url">
                  Swift中的字符串和集合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-10T19:26:25+11:00" content="2016-03-10">
              2016-03-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/10/Swift中的字符串和集合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/10/Swift中的字符串和集合/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Swift中的字符串是结构体，而NSString中的字符串是Class</p>
<h2 id="字符类型及表现形式"><a href="#字符类型及表现形式" class="headerlink" title="字符类型及表现形式"></a>字符类型及表现形式</h2><pre><code>var s:Character = &quot;美&quot;
var quote1 = &quot;\&apos;&quot;
var quote2 = &quot;\u{22}&quot;
println(&quot;quote1的值为:\(quote1),quote2的值为:\(quote2)&quot;)
</code></pre><ol>
<li>单个字符来指定字符常量，如“A”，“9”</li>
<li>转义字符表示特殊字符常量，如”\n”,”\t”</li>
<li>使用\u{n}的Unicode形式，n代表一个1~8位的十六进制</li>
<li>必须用双引号包起来</li>
<li>Swift中的每一个字符代表了一个可扩展字母集</li>
</ol>
<h2 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><pre><code>//创建方法1：直接赋值
var str1 = &quot;Jike&quot;
//创建方法2：构造函数
var str2 = String()

//创建多个重复字符的字符串
var str3 = String(count:4,repeatedValue:Character(&quot;a&quot;))
var strRep = String(count:4,repeatedValue:UnicodeScalar(&quot;xxxxx&quot;)) //使用unicode
println(strRep)

//判断字符串是否为空
println(str3.isEmpty)
</code></pre><h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><pre><code>//拼接方式1.
var str4 = str1 + &quot;College&quot;
str1 += &quot;Hello&quot;
println(str4)

//拼接方式2.
let char:Character = &quot;!&quot;
str1.append(char)
println(str1)
</code></pre><h2 id="字符串的字符数量"><a href="#字符串的字符数量" class="headerlink" title="字符串的字符数量"></a>字符串的字符数量</h2><pre><code>println(&quot;str3 has \(countElements(str3)) characters&quot;)
</code></pre><ol>
<li>通过调用全局countElement函数，并将字符串作为参数进行传递，可以获取该字符串的字符数量</li>
<li>Swift中的Unicode16Count函数所获得的值，才是和NSString中的length一样</li>
<li>Swift中的字符串是否可以修改仅通过定义的是变量还是常量来决定</li>
</ol>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><pre><code>let quotation = &quot;We are the same&quot;
let sameQuotation = &quot;We are the same&quot;
if quotation == sameQuotation {
println(&quot;These are the same&quot;)
}
</code></pre><h2 id="检查字符串是否有特定的前缀后缀"><a href="#检查字符串是否有特定的前缀后缀" class="headerlink" title="检查字符串是否有特定的前缀后缀"></a>检查字符串是否有特定的前缀后缀</h2><pre><code>var food = [&quot;Fruits:apple&quot;,
&quot;Fruits : orange&quot;,
&quot;Fruits : banana&quot;,
&quot;Vegetables: tomato&quot;,
&quot;Vegetables: potato&quot;]

for fry in food{
if fru.hasPrefix(&quot;Fruits&quot;){
   println(fru)
}

if fru.hasSuffix(&quot;o&quot;){
   println(fru)
}
}
</code></pre><h1 id="Swift中的数组"><a href="#Swift中的数组" class="headerlink" title="Swift中的数组"></a>Swift中的数组</h1><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1."></a>方式1.</h3><pre><code>var myArr = Array&lt;String&gt;()  
var num = Array&lt;Int&gt;(count:3,repeatedValue:1)
</code></pre><h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2."></a>方式2.</h3><pre><code>var someInts = [Int]()
var arr:[Int]=[1,2,3]
var threeDoubles = [Double](count:3, repeatedValue:0.0)
var food = [&quot;apple&quot;,&quot;orange&quot;,&quot;bnana&quot;]
println(food[3])
println(food.count)
</code></pre><h3 id="AnyObject-and-Any"><a href="#AnyObject-and-Any" class="headerlink" title="AnyObject and Any"></a>AnyObject and Any</h3><p>Swift中有两种特殊的object:  </p>
<ol>
<li>Any:表示任何数据类型</li>
<li>AnyObject:表示任何对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//因为数组里的数据不一样，这里的数组是AnyObject</span><br><span class="line">var shoppingList = [&quot;Eggs&quot;,123,true] </span><br><span class="line">    for item in shoppingList &#123;</span><br><span class="line">      println(item)</span><br><span class="line">&#125;     </span><br><span class="line">for fruit in food&#123;</span><br><span class="line">    fruit = &quot;good&quot; //error, fruit默认是let类型</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组的可变性"><a href="#数组的可变性" class="headerlink" title="数组的可变性"></a>数组的可变性</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><pre><code>//1. 用append()在数组尾部添加
food.append(&quot;Vegetables:mushroom&quot;)

//2. 通过加法添加数组元素
food += [&quot;pineapple&quot;,&quot;pity&quot;]
</code></pre><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><pre><code>food[0...2] = [&quot;a&quot;,&quot;b&quot;]
//从第一个到第三个元素进行替换，但只有两个元素，第三个将被删除，被“没有”所替换
</code></pre><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>food.insert(&quot;Meat&quot;,atIndex:0)
</code></pre><h3 id="删除某一项"><a href="#删除某一项" class="headerlink" title="删除某一项"></a>删除某一项</h3><pre><code>food.removeAtIndex(0)
</code></pre><h3 id="删除最后一项"><a href="#删除最后一项" class="headerlink" title="删除最后一项"></a>删除最后一项</h3><pre><code>food.removeLast()
</code></pre><h3 id="删除所有"><a href="#删除所有" class="headerlink" title="删除所有"></a>删除所有</h3><pre><code>food.removeAll(keepCapacity:false)
</code></pre><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><pre><code>//Dictionary&lt;KeyType,valueType&gt;
var dic1: Dictionary&lt;String,String&gt;

//[KeyType:valueType]
var scores:[String:Int]
</code></pre><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code>dic1 = Dictionary&lt;String,String&gt;()
scores = Dictionary&lt;String,Int&gt;(minimumCapacity;5)
</code></pre><h2 id="空字典"><a href="#空字典" class="headerlink" title="空字典"></a>空字典</h2><pre><code>var emptyDic:[String:Double] = [:] 
println(emptyDic.isEmpty)
</code></pre><h2 id="字典的使用"><a href="#字典的使用" class="headerlink" title="字典的使用"></a>字典的使用</h2><pre><code>//这种的声明是不严谨的，因为值的类型都不是一样的，系统会推断它是NSObject类型
var person = [&quot;age&quot;:18,&quot;name&quot;:&quot;Tom&quot;,&quot;身高&quot;:178]

//这样会报错，因为是将NSObject转为int
var height:Int? = person[&quot;身高&quot;]  
if height != nil {
   println(height!)
}

//以下才正确
var person = [&quot;age&quot;:18,&quot;name&quot;:&quot;Tom&quot;,&quot;身高&quot;:&quot;178&quot;]

var height:String? = person[&quot;身高&quot;]  
if height != nil {
   println(height!)
}

println(person[&quot;age&quot;])

//不存才的key，返回为nil
println(person[&quot;weight&quot;])

//对该值重新赋值
person[&quot;name&quot;] = &quot;Jack&quot;

//对不存在的key设置value,字典将会添加k-v对
person[&quot;weight&quot;] = 90
</code></pre><ol>
<li>数组是有序的，字典是无序的</li>
<li>通过常量或者变量决定字典是否可变</li>
<li>如果没有显示数据类型声明，字典就会根据值进行推断</li>
</ol>
<h2 id="字典的替换"><a href="#字典的替换" class="headerlink" title="字典的替换"></a>字典的替换</h2><ol>
<li>该方法返回更新值之前的原值</li>
<li>键不存在对应值的时候设置值</li>
<li>键存在时更新已存在的值</li>
<li>键不存在时，不发生替换，不返回任何东西</li>
</ol>
<pre><code>if let oldName = person.updateValue(&quot;Lucky&quot;,forKey:&quot;name&quot;){
   println(&quot;原来的值是:\(oldName)&quot;)
}
</code></pre><h2 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h2><pre><code>//使用元组
for (key,value) in person{
 println(&quot;\(key):\(value)&quot;)
} 
</code></pre><h2 id="字典的删除"><a href="#字典的删除" class="headerlink" title="字典的删除"></a>字典的删除</h2><pre><code>//移除单个值
person.removeValueForKey(&quot;name&quot;)

//移除所有值
person.removeAll(keepCapacity:false)
</code></pre><h2 id="字典键和值的取出"><a href="#字典键和值的取出" class="headerlink" title="字典键和值的取出"></a>字典键和值的取出</h2><pre><code>let keysArr = [String](person.keys)
let valueArr = [String](person.values)
println(valuesArr)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/Swift语言基础/" itemprop="url">
                  Swift语言基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-10T16:22:51+11:00" content="2016-03-10">
              2016-03-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IT/" itemprop="url" rel="index">
                    <span itemprop="name">IT</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/10/Swift语言基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/10/Swift语言基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><pre><code>var str = &quot;Hello&quot;  
var name = &quot;Lucky&quot;    
var age: Int  
var string: String = &quot;smile&quot;  
var a = 20, b:String, c = &quot;Swift&quot;  
println(&quot;Her name is \(name)&quot;)   //作为占位符&quot;\&quot; 
</code></pre><ol>
<li>变量var ,常量let    </li>
<li>标识符必须以字符(包括Unicode字符)，下划线_，美元符$开头，但不能以数字开头，不可以包含空格，不能使用关键字，其长度没有限制</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型：用Int就可以了"><a href="#整型：用Int就可以了" class="headerlink" title="整型：用Int就可以了"></a>整型：用Int就可以了</h2><pre><code>let oneMillion = 1_000_000 //可以增加下划线作为分隔符
println(oneMillion)
</code></pre><h2 id="整型之间转换必须是显式转换"><a href="#整型之间转换必须是显式转换" class="headerlink" title="整型之间转换必须是显式转换"></a>整型之间转换必须是显式转换</h2><pre><code>var book1: Int16 = 100
var book2: Int32 = 30
var totalPrice = Int32(book1) + book2 //必须先转换，否则会报错
</code></pre><h2 id="正无穷-负无穷-非数"><a href="#正无穷-负无穷-非数" class="headerlink" title="正无穷,负无穷,非数"></a>正无穷,负无穷,非数</h2><pre><code>var w = 4.0 / 0.0   //正无穷
var w = - 4.0 / 0.0 //负无穷
var f = 0.0 / 0.0   //非数
</code></pre><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><pre><code>var width: Float = 2.1
var height: Double = 3.9
var area1 = width * Float(height) //必须先转换，否则会报错
var area2 = Int(width) * 4 //必须先转换，否则会报错
</code></pre><h2 id="类型别名："><a href="#类型别名：" class="headerlink" title="类型别名："></a>类型别名：</h2><pre><code>typealias Age = UInt16
let myAge:Age = 10
</code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><pre><code>//赋值方式1.
var score = (140,140,&quot;Good&quot;)

//赋值方式2.赋值时必须为所有的成员变量赋值
var health : (Int , Int , String) 
health = (182 , 78 , &quot;Good&quot;)  

println (&quot;health元组的值为:\(health)&quot;)  //打印元组所有
println (&quot;health元组中身高的值为:\(health.1)&quot;) //打印元组中第二个值

//元组中的嵌套
var test:(Int,(Int,String))
test = (10,(100,&quot;Swift&quot;))
println(&quot;test元组中第二个元素的第一个元素为：\(test.1.0)&quot;)

//通过key-value赋值，顺序可以调换
var score2 = (math:140, English:140, Assessment:&quot;A&quot;)
var score2 :(math:Int, English:Int, Assessment:String)
score2 = (English:140, math:140, Assessment:&quot;A&quot;) 
println(&quot;score2 中数学的成绩是: \(score2.math)&quot;)
</code></pre><h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>任何已知类型后面紧跟?即可代表可选类型如Int?</p>
<pre><code>var str2 = &quot;HelloGeek&quot;
var num: Int? = str2.toInt()
println(num) //nil表示值缺失
</code></pre><h2 id="强制解析："><a href="#强制解析：" class="headerlink" title="强制解析："></a>强制解析：</h2><p>在变量或者常量后面添加!注意：必须可选类型的变量和常量确实有值的时候才能解析成功</p>
<pre><code>var num1: Int? = 10
var num2: Int? = 20

if num1 !=nil &amp;&amp; num !=nil{
   let sum = num1! + num2! //获得可选类型的值
}else{
   println(&quot;num1&quot;或者&quot;num2&quot;为nil,不能强制解析)
} 
</code></pre><h2 id="可选绑定："><a href="#可选绑定：" class="headerlink" title="可选绑定："></a>可选绑定：</h2><p>可以用在if和while语句中来对可选类型的值进行判断并把值赋给一个常量或者变量</p>
<pre><code>var str3: String! = &quot;Swift&quot;
if var tmp = str3 {
   println(&quot;str3 的值为: \(tmp)&quot;)
}else{
   println(&quot;str3 的值为nil,不能解析&quot;)
}
</code></pre><h2 id="隐式解析可选类型："><a href="#隐式解析可选类型：" class="headerlink" title="隐式解析可选类型："></a>隐式解析可选类型：</h2><p>在已有类型后面添加！如Int!适用于被赋值后不会重新变为nil的变量</p>
<pre><code>var possibleStr: String! = &quot;jikexueyuan&quot;
</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="swift赋值表达没有值，不支持连续赋值"><a href="#swift赋值表达没有值，不支持连续赋值" class="headerlink" title="swift赋值表达没有值，不支持连续赋值"></a>swift赋值表达没有值，不支持连续赋值</h2><pre><code>var a: Int
var b = a = 20
</code></pre><h2 id="求余运算"><a href="#求余运算" class="headerlink" title="求余运算"></a>求余运算</h2><pre><code>var g = 5.2 (结果正负取决于被除数的正负)
var h = 3.1
var mod = g % h
println(mod)
</code></pre><h2 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h2><pre><code>//结果是11，先执行运算，然后a再自加1
var a = 5
var b = a++ + 6
println(b) 

//结果是12，先自身加1，再执行运算
var a = 5
var b = ++a + 6
println(b)  
</code></pre><h2 id="溢出运算符-amp-amp-amp-amp-amp"><a href="#溢出运算符-amp-amp-amp-amp-amp" class="headerlink" title="溢出运算符 &amp;+ &amp;- &amp;* &amp;/ &amp;%"></a>溢出运算符 &amp;+ &amp;- &amp;* &amp;/ &amp;%</h2><pre><code>var willUnderflow = UInt8.min
willUnderflow = willUnderflow &amp;-1 //下溢

let a = 20
let b = a &amp;/ 0
let c = a &amp;% 0
</code></pre><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp; 按位与<br>|  或<br>^  异或<br>~  取反<br>&lt;&lt; 左位移<br>右位移 &gt;&gt;   </p>
<h2 id="扩展后的赋值运算符"><a href="#扩展后的赋值运算符" class="headerlink" title="扩展后的赋值运算符"></a>扩展后的赋值运算符</h2><p>-=<br>*=<br>/=<br>&amp;=<br>|=<br>运算符 “+= ” 对于 x+=y 等价于 x = x+y    </p>
<h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><p>a..&lt;b (包含a,但不包含b)<br>a…b（包含a,也包含b）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a in 0..&lt;10&#123;</span><br><span class="line">println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a in 0...10&#123;</span><br><span class="line">println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较运算符，结果为BOOL值"><a href="#比较运算符，结果为BOOL值" class="headerlink" title="比较运算符，结果为BOOL值"></a>比较运算符，结果为BOOL值</h2><pre><code>var c= a === b //只有a和b指向的类型实例相同时，c为true
</code></pre><ol>
<li>=== 特征相等运算符  </li>
<li>!== 特征不等运算符  </li>
</ol>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;&amp; 与<br>|| 或<br>!  非</p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 5</span><br><span class="line">var b = 3</span><br><span class="line">var str = a &gt; b ? &quot;a大于b&quot;:&quot;a小于b&quot; //如果条件成立就执行?后的，否则就执行:后的</span><br></pre></td></tr></table></figure>
<h2 id="空合并运算符-a-b"><a href="#空合并运算符-a-b" class="headerlink" title="空合并运算符 a??b"></a>空合并运算符 a??b</h2><ol>
<li>将对可选类型a进行空判断，如果a包含一个值就进行解封</li>
<li>否则就返回一个默认值b  </li>
<li>默认值b的类型必须要和a存储值的类型保持一致  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let words = &quot;hello&quot;</span><br><span class="line">var say: String? = &quot;jike&quot; </span><br><span class="line">var content = say ?? words</span><br><span class="line">println(content)</span><br></pre></td></tr></table></figure>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h3><p>语句的条件执行体必须放在花括号中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age = 30</span><br><span class="line">if age &gt; 20 &#123;</span><br><span class="line">  println(“年龄大于20岁”)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  println(&quot;年龄小于20岁&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><ol>
<li>任意一个case不需要break,执行完一条会自动退出  </li>
<li>每一个case块至少包含一条语句</li>
<li>case标签后可以有多个值，用逗号隔开</li>
<li>case块后的条件还可以是一个范围或者元组，支持值绑定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let score = &quot;a&quot;</span><br><span class="line">switch score &#123;  </span><br><span class="line">case &quot;A&quot;,&quot;a&quot;:</span><br><span class="line"> println(&quot;Good&quot;)</span><br><span class="line">case &quot;B&quot;:</span><br><span class="line"> println(&quot;LG&quot;)</span><br><span class="line">case &quot;C&quot;:</span><br><span class="line"> println(&quot;TW4&quot;)</span><br><span class="line">case &quot;D&quot;:</span><br><span class="line"> println(&quot;Good&quot;)</span><br><span class="line">case &quot;E&quot;:</span><br><span class="line"> println(&quot;Good&quot;)</span><br><span class="line">default:</span><br><span class="line"> println(&quot;error&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用fallthrough语句贯穿"><a href="#使用fallthrough语句贯穿" class="headerlink" title="使用fallthrough语句贯穿"></a>使用fallthrough语句贯穿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var num = 5</span><br><span class="line">var desc = &quot;\(num)是&quot;</span><br><span class="line">switch num &#123;</span><br><span class="line">case 2, 3, 5, 7 :</span><br><span class="line">     desc += &quot;质数，而且还是&quot;</span><br><span class="line">	 fallthrough</span><br><span class="line">default:</span><br><span class="line">     desc += &quot;整数&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(desc) //结果是“5是质数，而且还是整数”</span><br></pre></td></tr></table></figure>
<h3 id="case后的条件为元组"><a href="#case后的条件为元组" class="headerlink" title="case后的条件为元组"></a>case后的条件为元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var point = (x:1 , y:1)</span><br><span class="line">switch point &#123;</span><br><span class="line">case (0,0):</span><br><span class="line">    println(&quot;(0,0)位于原点&quot;)</span><br><span class="line">case (_,0):   //用_表示可以忽略这个数据</span><br><span class="line">    println(&quot;(\(point.0),0)位于x轴上&quot;)</span><br><span class="line">case (0...Int.max, 0...Int.max):</span><br><span class="line">    println(&quot;(\(point.0),\(point.1))位于第一象限&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var point = (x:1 , y:1)</span><br><span class="line">switch point &#123;</span><br><span class="line">case (0,0):</span><br><span class="line">   println(&quot;(0,0)位于原点&quot;)</span><br><span class="line">case (var a, 0)://y坐标为0，进入该case块，并将元组的x成员绑定到临时变量a</span><br><span class="line">   println(&quot;该点位于x轴上，x值为:\(a)&quot;)</span><br><span class="line">case var (x,y) where x&gt;0 &amp;&amp; y&gt;0:  //条件值绑定</span><br><span class="line">   println(&quot;(\(x),\(y))位于第一象限&quot;)</span><br><span class="line">default:</span><br><span class="line">   break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for var count = 0; count &lt;10; count++&#123;</span><br><span class="line">   println(count)</span><br><span class="line">&#125;</span><br><span class="line">let base = 3</span><br><span class="line">let power = 10</span><br><span class="line">var answer = 1</span><br><span class="line">for _ in 1...power &#123; //下划线符号_替代循环中的变量，能够忽略具体的值，并且不提供循环遍历时对值的访问</span><br><span class="line">  answer *= base</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标签："><a href="#标签：" class="headerlink" title="标签："></a>标签：</h3><p>紧跟冒号的标识符，只有放在循环语句或者switch语句之前才有作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">outer: for var i=0;i&lt;5;i++&#123;</span><br><span class="line">内层循环</span><br><span class="line">for var j=0;j&lt;3;j++&#123;</span><br><span class="line">   println(&quot;i的值为:\(i),j的值为\(j)&quot;)</span><br><span class="line">   if j==1 &#123;</span><br><span class="line">     break outer</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>break结束循环，开始执行循环之后的代码</li>
<li>continue 忽略本次循环的剩下语句，执行下一次循环，但不终止循环</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Jack Liu" />
          <p class="site-author-name" itemprop="name">Jack Liu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Liu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'cowboyTech';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  
  

  
  


</body>
</html>
